<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>mcyoung</title>
 <link href="https://mcyoung.xyz/atom.xml" rel="self"/>
 <link href="https://mcyoung.xyz/"/>
 <updated>2021-05-27T00:07:22-04:00</updated>
 <id>https://mcyoung.xyz</id>
 <author>
   <name>Miguel Young de la Sota</name>
   <email></email>
 </author>

 
 <entry>
   <title>The Taxonomy of Pointers</title>
   <link href="https://mcyoung.xyz/2021/05/24/ptr-taxonomy/"/>
   <updated>2021-05-24T00:00:00-04:00</updated>
   <id>https://mcyoung.xyz/2021/05/24/ptr-taxonomy</id>
   <content type="html">&lt;p&gt;Writing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe&lt;/code&gt; in Rust usually involves manual management of memory. Although,
ideally, we’d like to exclusively use references for this, sometimes the
constraints they apply are too strong. This post is a guide on those constraints
and how to weaken them for correctness.&lt;/p&gt;

&lt;p&gt;“Unmanaged” languages, like C++ and Rust, provide &lt;em&gt;pointer&lt;/em&gt; types for
manipulating memory. These types serve different purposes and provide different
guarantees. These guarantees are useful for the optimizer but get in the way of
correctness of low-level code. This is especially true in Rust, where these
constraints are very tight.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;NB: This post only surveys &lt;em&gt;data&lt;/em&gt; pointers. Function pointers are their own
beast, but generally are less fussy, since they all have static
lifetime&lt;sup id=&quot;fnref:go-nuts&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:go-nuts&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;basic-c-pointers&quot;&gt;&lt;a href=&quot;#basic-c-pointers&quot;&gt;Basic C++ Pointers&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;First, let’s survey C++. We have three pointer types: the traditional C pointer
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T*&lt;/code&gt;, C++ references &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&amp;amp;&lt;/code&gt;, and rvalue references &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&amp;amp;&amp;amp;&lt;/code&gt;. These generally have
pretty weak guarantees.&lt;/p&gt;

&lt;p&gt;Pointers provide virtually no guarantees at all: they can be null, point to
uninitialized memory, or point to nothing at all! C++ Only requires that they
be aligned&lt;sup id=&quot;fnref:unaligned&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:unaligned&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;. They are little more than an address (until they are
dereferenced, of course).&lt;/p&gt;

&lt;p&gt;References, on the other hand, are intended to be the “primary” pointer type. A
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&amp;amp;&lt;/code&gt; cannot be null, is well-aligned, and is intended to only refer to live
memory (although it’s not something C++ can really guarantee for lack of a
borrow-checker). References are short-lived.&lt;/p&gt;

&lt;p&gt;C++ uses non-nullness to its advantage. For example, Clang will absolutely
delete code of the form&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;C++&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;DoSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Because references cannot be null, and dereferencing the null pointer is always
UB, the compiler may make this fairly strong assumption.&lt;/p&gt;

&lt;p&gt;Rvalue references, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, are not meaningfully different from normal references,
beyond their role in overload resolution.&lt;/p&gt;

&lt;p&gt;Choosing a C++ (primitive) pointer type is well-studied and not the primary
purpose of this blog. Rather, we’re interested in how these map to Rust, which
has significantly more complicated pointers.&lt;/p&gt;

&lt;h2 id=&quot;basic-rust-pointers&quot;&gt;&lt;a href=&quot;#basic-rust-pointers&quot;&gt;Basic Rust Pointers&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Like C++, Rust has two broad pointer types: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*const T&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*mut T&lt;/code&gt;, the raw
pointers, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;T&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt;, the references.&lt;/p&gt;

&lt;p&gt;Rust pointer have even fewer constraints than C++ pointers; they need not even
be aligned&lt;sup id=&quot;fnref:unaligned-access&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:unaligned-access&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;! The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mut&lt;/code&gt; specifier is basically
irrelevant, but is useful as programmer book-keeping tool. Rust also does not
enforce the dreaded strict-aliasing rule&lt;sup id=&quot;fnref:strict-aliasing&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:strict-aliasing&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; on its pointers.&lt;/p&gt;

&lt;p&gt;On the other hand, Rust references are among the most constrained objects in any
language that I know of. A shared reference &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;'a T&lt;/code&gt;, lasting for the lifetime
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'a&lt;/code&gt;, satisfies:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Non-null, and well-aligned (like in C++).&lt;/li&gt;
  &lt;li&gt;Points to a valid, initialized &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; for the duration of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'a&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; is never ever mutated for the duration of the reference: the compiler may
fold separate reads into one at will. Stronger still, no &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt; is reachable
from any thread while the reference is reachable.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Stronger still are &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;'a mut T&lt;/code&gt; references, sometimes called &lt;em&gt;unique&lt;/em&gt; references,
because in addition to being well-aligned and pointing to a valid &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; at all
times, no other reachable reference ever aliases it in any thread; this is
equivalent to a C &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T* restrict&lt;/code&gt; pointer.&lt;/p&gt;

&lt;p&gt;Unlike C++, which has two almost-identical pointer types, Rust’s two pointer
types provide either no guarantees or &lt;em&gt;all&lt;/em&gt; of them. The following &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe&lt;/code&gt;
operations are all UB:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;*&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// A reference to u8 need not be sufficiently aligned&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// for a reference to u32.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unaligned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0u8&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// More on this type later...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uninit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;*&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;MaybeUninit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;uninit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// Not UB in C++ with const_cast!&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Two mutable references live at the same time pointing to&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// the same memory. This would also be fine in C++!&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;wide-pointers&quot;&gt;&lt;a href=&quot;#wide-pointers&quot;&gt;Wide Pointers&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Rust also provides the slice types &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;[T]&lt;/code&gt;&lt;sup id=&quot;fnref:std-span&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:std-span&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; (of which you get
mutable/immutable reference and pointer varieties) and dynamic trait object
types &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;dyn Tr&lt;/code&gt; (again, all four basic pointer types are available).&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;[T]&lt;/code&gt; is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;usize&lt;/code&gt;&lt;sup id=&quot;fnref:usize&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:usize&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt; length plus a pointer to that many &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt;s. The pointer
type of the slice specifies the guarantees on the pointed-to buffer. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*mut [T]&lt;/code&gt;,
for example, has no meaningful guarantees, but still contains the length&lt;sup id=&quot;fnref:ptr-len&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:ptr-len&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;.
Note that the length is part of the pointer value, &lt;em&gt;not&lt;/em&gt; the pointee.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;dyn Tr&lt;/code&gt; is a trait object. For our purposes, it consists of a pointer to some
data plus a pointer to a static vtable. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*mut dyn Tr&lt;/code&gt; is technically a valid
type&lt;sup id=&quot;fnref:raw-vtable&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:raw-vtable&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;. Overall, trait objects aren’t really relevant to this
post; they are rarely used this way in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe&lt;/code&gt; settings.&lt;/p&gt;

&lt;h2 id=&quot;weakening-the-guarantees&quot;&gt;&lt;a href=&quot;#weakening-the-guarantees&quot;&gt;Weakening the Guarantees&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Suppose we’re building some kind of data structure; in Rust, data structures
will need some sprinkling of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe&lt;/code&gt;, since they will need to shovel around
memory directly. Typically this is done using raw pointers, but it is preferable
to use the &lt;em&gt;least weakened&lt;/em&gt; pointer type to allow the compiler to perform
whatever optimizations it can.&lt;/p&gt;

&lt;p&gt;There are a number of orthogonal guarantees on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;T&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt; we might want
to relax:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Non-nullness.&lt;/li&gt;
  &lt;li&gt;Well-aligned-ness.&lt;/li&gt;
  &lt;li&gt;Validity and initialized-ness of the pointee.&lt;/li&gt;
  &lt;li&gt;Allocated-ness of the pointee (implied by initialized-ness).&lt;/li&gt;
  &lt;li&gt;Global uniqueness of an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pointer-to-zst&quot;&gt;&lt;a href=&quot;#pointer-to-zst&quot;&gt;Pointer to ZST&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The last three of these properties are irrelevant for a zero-sized type. For
example, we can generate infinite &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut ()&lt;/code&gt; with no consequences:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;unique_unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0x1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We materialize a non-null, well-aligned pointer and reborrow it into a static
reference; because there is no data to point to, none of the usual worries about
the pointee itself apply. However, the pointer itself must still be non-null and
well-aligned; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x1&lt;/code&gt; is not a valid address for an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;[u32; 0]&lt;/code&gt;, but &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x4&lt;/code&gt;
is&lt;sup id=&quot;fnref:but-you-cannot-free-it&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:but-you-cannot-free-it&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;This also applies to empty slices; in fact, the compiler will happily promote
the expression &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut []&lt;/code&gt; to an arbitrary lifetime:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unique_empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;null-references&quot;&gt;&lt;a href=&quot;#null-references&quot;&gt;Null References&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The most well-known manner of weakening is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;. Rust guarantees that
this is ABI-compatible with a C pointer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const T*&lt;/code&gt;, with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option::&amp;lt;&amp;amp;T&amp;gt;::None&lt;/code&gt;
being a null pointer on the C side. This “null pointer optimization” applies to
any type recursively containing at least one &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&amp;amp;&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DoSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;do_something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;DoSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// C will see a `NULL` as the argument.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The same effect can be achieved for a pointer type using the
&lt;a href=&quot;https://doc.rust-lang.org/std/ptr/struct.NonNull.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; standard
library type: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&amp;lt;NonNull&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is identical to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*mut T&lt;/code&gt;. This is most
beneficial for types which would otherwise contain a raw pointer:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NonNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;assert_eq!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;size_of&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;size_of&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;uninitialized-pointee&quot;&gt;&lt;a href=&quot;#uninitialized-pointee&quot;&gt;Uninitialized Pointee&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;No matter what, a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;T&lt;/code&gt; cannot point to uninitialized memory, since the compiler
is free to assume it may read such references at any time with no consequences.&lt;/p&gt;

&lt;p&gt;The following classic C pattern is verboten:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;C&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;initialize_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Rust doesn’t provide any particularly easy ways to allocate memory without
initializing it, too, so this usually isn’t a problem. The
&lt;a href=&quot;https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.assume_init_ref&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;
type can be used for safely allocating memory without initializing it, via
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MaybeUninit::uninit()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This type acts as a sort of “optimization barrier” that prevents the compiler
from assuming the pointee is initialized. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer to
potentially uninitialized but definitely allocated memory. It has the
same layout as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;T&lt;/code&gt;, and Rust provides functions like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assume_init_ref()&lt;/code&gt; for
asserting that a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; is definitely initialized. This assertion is
similar in consequence to dereferencing a raw pointer.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; should almost be viewed as pointer
types in their own right, since they can be converted to/from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;T&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt;
under certain circumstances.&lt;/p&gt;

&lt;p&gt;Because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; is almost a “subtype” of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;, we are
entitled&lt;sup id=&quot;fnref:requires-transmute&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:requires-transmute&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt; to “forget” that the referent of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;T&lt;/code&gt; is
initialized converting it to a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;. This makes sense because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;T&lt;/code&gt;
is covariant&lt;sup id=&quot;fnref:covariance&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:covariance&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;11&lt;/a&gt;&lt;/sup&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;T&lt;/code&gt;. However, this is not true of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt;, since
it’s not covariant:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uninit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MaybeUninit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transmute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uninit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MaybeUninit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;uninit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// Oops, `x` is now uninit!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These types are useful for talking to C++ without giving up too many guarantees.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&amp;lt;&amp;amp;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is an almost perfect model of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const T*&lt;/code&gt;, under the
assumption that most pointers in C++ are valid most of the time.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; also finds use in working with raw blocks of memory, such as in
a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Vec&lt;/code&gt;-style growable slice:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SliceVec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// Backing memory. The first `len` elements of it are&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// known to be initialized, but no more than that.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MaybeUninit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SliceVec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MaybeUninit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;aliased-pointee&quot;&gt;&lt;a href=&quot;#aliased-pointee&quot;&gt;Aliased Pointee&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt; can never alias any other pointer, but is also the mechanism by which
we perform mutation. It can’t even alias with pointers that Rust can’t see; Rust
assumes no one else can touch this memory. Thus, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt; is not an appropriate
analogue for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&amp;amp;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Like with uninitialized memory, Rust provides a “barrier” wrapper type,
&lt;a href=&quot;https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the “interior mutability” primitive, which permits us to
mutate through an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; so long as concurrent reads and writes do not
occur. We may even convert it to a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt; when we’re sure we’re holding the
only reference.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; forms the basis of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;
types, each of which performs a sort of “dynamic borrow-checking”:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; only permits direct loads and stores.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; maintains a counter of references into it, which it uses to
dynamically determine if a mutable reference would be unique.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, which is like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; but using concurrency primitives to
maintain uniqueness.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because of this, Rust must treat &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; as always aliasing, but
because we can mutate through it, it is a much closer analogue to a C++ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&amp;amp;&lt;/code&gt;.
However, because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;T&lt;/code&gt; assumes the pointee is never mutated, it cannot coexist
with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; to the same memory, if mutation is performed through it.
The following is explicitly UB:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// This is ok; creating the reference to UnsafeCell does not&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// immediately trigger UB.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;transmute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UnsafeCell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// But writing to it does!&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; type is useful for non-aliasing references to plain-old-data types,
which tend to be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Copy&lt;/code&gt;. It allows us to perform mutation without having to
utter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe&lt;/code&gt;. For example, the correct type for a shared mutable buffer in
Rust is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;[Cell&amp;lt;u8&amp;gt;]&lt;/code&gt;, which can be freely &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memcpy&lt;/code&gt;‘d,
without worrying about aliasing&lt;sup id=&quot;fnref:but-thread-safety&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:but-thread-safety&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;This is most useful for sharing memory with another language, like C++, which
cannot respect Rust’s aliasing rules.&lt;/p&gt;

&lt;h3 id=&quot;combined-barriers&quot;&gt;&lt;a href=&quot;#combined-barriers&quot;&gt;Combined Barriers&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;To recap:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Non-nullness can be disabled with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Initialized-ness can be disabled with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Uniqueness can be disabled with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;There is no way to disable alignment and validity restrictions: references
must always be aligned and have a valid lifetime attached. If these are
unachievable, raw pointers are your only option.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can combine these various “weakenings” to produce aligned, lifetime-bound
references to data with different properties. For example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;UnsafeCell&amp;lt;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is as close as we can get to a C++ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&amp;amp;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&amp;lt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is a like a raw pointer, but to initialized memory.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&amp;lt;&amp;amp;mut MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is like a raw pointer, but with alignment,
aliasing, and lifetime requirements.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UnsafeCell&amp;lt;&amp;amp;[T]&amp;gt;&lt;/code&gt; permits us to mutate the pointer to the buffer and its
length, but not the values it points to themselves.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UnsafeCell&amp;lt;&amp;amp;[UnsafeCell&amp;lt;T&amp;gt;]&amp;gt;&lt;/code&gt; lets us mutate both the buffer and its actual
pointer/length.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Interestingly, there is no equivalent to a C++ raw pointer: there is no way
to create a guaranteed-aligned pointer without a designated lifetime&lt;sup id=&quot;fnref:unsafe-lifetime&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:unsafe-lifetime&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;13&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id=&quot;other-pointers&quot;&gt;&lt;a href=&quot;#other-pointers&quot;&gt;Other Pointers&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Rust and C++ have many other pointer types, such as smart pointers. However, in
both languages, both are built in terms of these basic pointer types. Hopefully
this article is a useful reference for anyone writing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe&lt;/code&gt; abstraction that
wishes to avoid using raw pointers when possible. ◼&lt;/p&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:go-nuts&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;Except in Go, which synthesizes vtables &lt;em&gt;on the fly&lt;/em&gt;. Story for another day. &lt;a href=&quot;#fnref:go-nuts&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:unaligned&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;It is, apparently, a little-known fact that constructing unaligned pointers,
but then never dereferencing them, is still UB in C++. C++ could, for
example, store information in the lower bits of such a pointer. The
in-memory representation of a pointer is actually unspecified! &lt;a href=&quot;#fnref:unaligned&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:unaligned-access&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;This is useful when paired with the Rust &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;*const T&amp;gt;::read_unaligned()&lt;/code&gt;
function, which can be compiled down to a normal load on architectures that
do not have alignment restrictions, like x86_64 and aarch64. &lt;a href=&quot;#fnref:unaligned-access&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:strict-aliasing&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Another story for another time. &lt;a href=&quot;#fnref:strict-aliasing&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:std-span&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;Comparable to the C++20 &lt;a href=&quot;https://en.cppreference.com/w/cpp/container/span&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::span&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;
type. &lt;a href=&quot;#fnref:std-span&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:usize&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;usize&lt;/code&gt; is Rust’s machine word type, compare &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::uintptr_t&lt;/code&gt;. &lt;a href=&quot;#fnref:usize&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ptr-len&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;The length of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*mut [T]&lt;/code&gt; can be accessed via the unstable
&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.pointer.html#method.len-1&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;*mut [T]&amp;gt;::len()&lt;/code&gt;&lt;/a&gt;
method. &lt;a href=&quot;#fnref:ptr-len&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:raw-vtable&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;It is also not a type I have encountered enough to have much knowledge on.
For example, I don’t actually know if the vtable half of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*mut dyn Tr&lt;/code&gt;
must always be valid or not; I suspect the answer is “no”, but I couldn’t
find a citation for this. &lt;a href=&quot;#fnref:raw-vtable&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:but-you-cannot-free-it&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;Note that you &lt;em&gt;cannot&lt;/em&gt; continue to use a reference to freed, zero-sized
memory. This subtle distinction is called out in
&lt;a href=&quot;https://doc.rust-lang.org/std/ptr/index.html#safety&quot;&gt;https://doc.rust-lang.org/std/ptr/index.html#safety&lt;/a&gt;. &lt;a href=&quot;#fnref:but-you-cannot-free-it&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:requires-transmute&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;Currently, a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transmute&lt;/code&gt; must be used to perform this operation, but I see
no reason way this would permit us to perform an illegal mutation without
uttering &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe&lt;/code&gt; a second time. In particular, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MaybeUninit::assume_init_read()&lt;/code&gt;,
which could be used to perform illegal copies, is an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe&lt;/code&gt; function. &lt;a href=&quot;#fnref:requires-transmute&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:covariance&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;A covariant type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cov&amp;lt;T&amp;gt;&lt;/code&gt; is once where, if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; is a subtype of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;U&lt;/code&gt;, then
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cov&amp;lt;T&amp;gt;&lt;/code&gt; is a subtype of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cov&amp;lt;U&amp;gt;&lt;/code&gt;. This isn’t particularly noticeable in
Rust, where the only subtyping relationships are &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;'a T&lt;/code&gt; subtypes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;'b T&lt;/code&gt;
when &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'a&lt;/code&gt; outlives &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'b&lt;/code&gt;, but is nonetheless important for advanced type
design. &lt;a href=&quot;#fnref:covariance&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:but-thread-safety&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; does not provide synchronization; you still need locks to share it
between threads. &lt;a href=&quot;#fnref:but-thread-safety&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:unsafe-lifetime&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;I have previously proposed a sort of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'unsafe&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'!&lt;/code&gt; “lifetime” that is
intended to be the lifetime of dangling references (a bit of an oxymoron).
This would allow us to express this concept, but I need to flesh out the
concept more. &lt;a href=&quot;#fnref:unsafe-lifetime&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Move Constructors in Rust:
Is it possible?
</title>
   <link href="https://mcyoung.xyz/2021/04/26/move-ctors/"/>
   <updated>2021-04-26T00:00:00-04:00</updated>
   <id>https://mcyoung.xyz/2021/04/26/move-ctors</id>
   <content type="html">&lt;p&gt;I’ve been told I need to write this idea down – I figure this one’s a good
enough excuse to start one of them programming blogs.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TL;DR&lt;/em&gt; You &lt;em&gt;can&lt;/em&gt; move-constructors the Rust! It requires a few macros but isn’t
much more outlandish than the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;async&lt;/code&gt; pinning state of the art. A prototype of
this idea is implemented in my &lt;a href=&quot;https://crates.io/crates/moveit&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;moveit&lt;/code&gt;&lt;/a&gt; crate.&lt;/p&gt;

&lt;h2 id=&quot;the-interop-problem&quot;&gt;&lt;a href=&quot;#the-interop-problem&quot;&gt;The Interop Problem&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Rust is the best contender for a C++ replacement; this is not even a question at
this point&lt;sup id=&quot;fnref:cc-replacement&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:cc-replacement&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. It’s a high-level language that provides users with
appropriate controls over memory, while also being memory safe. Rust
accomplishes by codifying C++ norms and customs around ownership and lifetimes
into its type system.&lt;/p&gt;

&lt;p&gt;Rust has an ok&lt;sup id=&quot;fnref:bindgen&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:bindgen&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; FFI story for C:&lt;/p&gt;

&lt;div class=&quot;code-multicol&quot;&gt;

  &lt;figure class=&quot;highlight&quot; pretty-lang=&quot;C&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;into_rust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;into_c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;into_rust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
  &lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;into_c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;#[no_mangle]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;into_rust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;into_c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Calling into either of these functions from the Rust or C side will recurse
infinitely across the FFI boundary. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extern &quot;C&quot; {}&lt;/code&gt; item on the Rust side
declares C symbols, much like a function prototype in C would; the
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extern &quot;C&quot; fn&lt;/code&gt; is a Rust function with the C calling convention, and the
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#[no_mangle]&lt;/code&gt; annotation ensures that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recurse_into_rust&lt;/code&gt; is the name that the
linker sees for this function. The link works out, we run our program, and the
stack overflows. All is well.&lt;/p&gt;

&lt;p&gt;But this is C. We want to rewrite all of the world’s C++ in Rust, but
unfortunately that’s going to take about a decade, so in the meantime new Rust
must be able to call existing C++, and vise-versa. C++ has a much crazier ABI,
and while Rust gives us the minimum of passing control to C, libraries like
&lt;a href=&quot;https://cxx.rs/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cxx&lt;/code&gt;&lt;/a&gt; need to provide a bridge on top of this for Rust and C++ to talk to each
other.&lt;/p&gt;

&lt;p&gt;Unfortunately, the C++ and Rust object models are, a priori, incompatible.
In Rust, &lt;em&gt;every object&lt;/em&gt; may be “moved” via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memcpy&lt;/code&gt;, whereas in C++ this only
holds for types satisfying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::is_trivially_moveable&lt;/code&gt;&lt;sup id=&quot;fnref:relocatable&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:relocatable&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;.
Some types require calling a &lt;em&gt;move constructor&lt;/em&gt;, or may not be moveable at all!&lt;/p&gt;

&lt;p&gt;Even more alarming, C++ types are permited to take the address of the location
where they are being constructed: the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this&lt;/code&gt; pointer is always accessible,
allowing easy creation of self-referential types:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;C++&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cyclic&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Cyclic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
 
  &lt;span class=&quot;c1&quot;&gt;// Ensure that copy and move construction respect the self-pointer&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// invariant:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Cyclic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cyclic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cyclic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// snip: Analogous for other rule-of-five constructors.&lt;/span&gt;

 &lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Cyclic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The solution &lt;a href=&quot;https://cxx.rs/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cxx&lt;/code&gt;&lt;/a&gt; and other FFI strategies take is to box up complex C++
objects across the FFI boundary; a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::unique_ptr&amp;lt;Cyclic&amp;gt;&lt;/code&gt; (perhaps
reinterpreted as a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Box&lt;/code&gt; on the Rust side) can be passed around without needing
to call move constructors. The heap allocation is a performance
regression that scares off potential Rust users, so it’s not a viable solution.&lt;/p&gt;

&lt;p&gt;We can do better.&lt;/p&gt;

&lt;h3 id=&quot;notation-and-terminology&quot;&gt;&lt;a href=&quot;#notation-and-terminology&quot;&gt;Notation and Terminology&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;“Move” is a very, very overloaded concept across Rust and C++, and many people
have different names for what this means. So that we don’t get confused, we’ll
establish some terminology to use throughout the rest of the article.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;destructive move&lt;/em&gt; is a Rust-style move, which has the following properties:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It does not create a new object; from the programmer’s perspective, the object
has simply changed address.&lt;/li&gt;
  &lt;li&gt;The move is implemented by a call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memcpy&lt;/code&gt;; no user code is run.&lt;/li&gt;
  &lt;li&gt;The moved-from value becomes inaccessible and its destructor does not run.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A destructive move, in effect, is completely invisible to the user&lt;sup id=&quot;fnref:swappy&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:swappy&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;, and
the Rust compiler can emit as many or as few of them as it likes. We will refer
to this as a “destructive move”, a “Rust move”, or a “blind, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memcpy&lt;/code&gt; move”.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;copying move&lt;/em&gt; is a C++-style move, which has the following properties:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It creates a new, distinct object at a new memory location.&lt;/li&gt;
  &lt;li&gt;The move is implemented by calling a user-provided function that initializes
the new object.&lt;/li&gt;
  &lt;li&gt;The moved-from value is still accessible but in an “unspecified but valid
state”. Its destructor is run once the current scope ends.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A copying move is just a weird copy operation that mutates the copied-from
object. C++ compilers &lt;em&gt;may&lt;/em&gt; elide calls to the move constructor in certain
situations, but calling it usually requires the programmer to explicitly ask for
it. From a Rust perspective, this is as if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clone::clone()&lt;/code&gt; took &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut self&lt;/code&gt; as
an argument. We will refer to this as a “copying move”, a “nondestructive move”,
a “C++ move”, or, metonymically, as a “move constructor”.&lt;/p&gt;

&lt;h2 id=&quot;pinned-pointers&quot;&gt;&lt;a href=&quot;#pinned-pointers&quot;&gt;Pinned Pointers&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;As part of introducing support for stackless coroutines&lt;sup id=&quot;fnref:pinned-futures&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:pinned-futures&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;
(aka &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;async&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;await&lt;/code&gt;), Rust had to provide some kind of supported for immobile
types through &lt;em&gt;pinned pointers&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/std/pin/index.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&lt;/code&gt;&lt;/a&gt; type is a wraper around a pointer type, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;&amp;amp;mut i32&amp;gt;&lt;/code&gt; or
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;Box&amp;lt;ComplexObject&amp;gt;&amp;gt;&lt;/code&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&lt;/code&gt; provides the following guarantee to unsafe
code:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p: Pin&amp;lt;P&amp;gt;&lt;/code&gt; for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P: Deref&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P::Target: !Unpin&lt;/code&gt;, the pointee object
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*p&lt;/code&gt; will always be found at that address, and no other object will use that
address until &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*p&lt;/code&gt;’s destructor is called.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In a way, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; is a witness to a sort of critical section: once constructed,
that memory is &lt;em&gt;pinned&lt;/em&gt; until the destructor runs. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&lt;/code&gt; documentation goes
into deep detail about when and why this matters, and how unsafe code can
take advantage of this guarantee to provide a safe interface.&lt;/p&gt;

&lt;p&gt;The key benefit is that unsafe code can create self-references behind the pinned
pointer, without worrying about them breaking when a destructive move occurs.
C++ deals with this kind of type by allowing move/copy constructors to observe
the new object’s address and fix up any self references as necessary.&lt;/p&gt;

&lt;p&gt;Our progress so far: C++ types can be immoveable from Rust’s
perspective. They need to be pinned in some memory location: either on the heap
as a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, or on the stack (somehow; keep reading). Our program is now
to reconcile C++ move constructors with this standard library object that
explicitly prevents moves. Easy, right;&lt;/p&gt;

&lt;h2 id=&quot;constructors&quot;&gt;&lt;a href=&quot;#constructors&quot;&gt;Constructors&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;C++ constructors are a peculiar thing. Unlike Rust’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo::new()&lt;/code&gt;-style
factories, or even constructors in dynamic languages like Java, C++ constructors
are unique in that they construct a value in a &lt;em&gt;specific location&lt;/em&gt;. This concept
is best illustraced by the &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/new#Placement_new&quot;&gt;&lt;em&gt;placement-&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt;&lt;/em&gt;&lt;/a&gt; operation:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;C++&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MakeString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mwahahaha&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Placement-&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt; is one of those exotic C++ operations you only ever run into
deep inside fancy library code. Unlike &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt;, which triggers a trip into the
allocator, placement-&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt; simply calls the constructor of your type with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this&lt;/code&gt;
set to the argument in parentheses. This is the “most raw” way you can call a
constructor: given a memory location and arguments, construct a new value.&lt;/p&gt;

&lt;p&gt;In Rust, a method call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.bar()&lt;/code&gt; is really syntax sugar for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo::bar(foo)&lt;/code&gt;.
This is not the case in C++; a member function has an altogether different type,
but some simple template metaprogramming can flatten it back into a regular old
free function:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;C++&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FreeBar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FreeBar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Placement-&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt; lets us do the analogous thing for a constructor:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;C++&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FreeFoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AllocateSomehow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FreeFoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can lift this “flattening” of a specific constructor into Rust, using the
existing vocabulary for pushing fixed-address memory around:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ctor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MaybeUninit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor&lt;/code&gt; is a &lt;em&gt;constructing closure&lt;/em&gt;. A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor&lt;/code&gt; contains the necessary
information for constructing a value of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Output&lt;/code&gt; which will live at the
location &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*dest&lt;/code&gt;. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor::ctor()&lt;/code&gt; function performs in-place construction,
making &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*dest&lt;/code&gt; become initialized.&lt;/p&gt;

&lt;p&gt;A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor&lt;/code&gt; is not the constructor itself; rather, it is more like a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; or
an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Iterator&lt;/code&gt; which contain the necessary captured values to perform the
operation. A Rust type that is constructed using a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor&lt;/code&gt; would have functions
like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ctor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe&lt;/code&gt; markers serve distinct purposes:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It is an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe trait&lt;/code&gt;, because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*dest&lt;/code&gt; must be initialized when &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctor()&lt;/code&gt;
returns.&lt;/li&gt;
  &lt;li&gt;It has an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe fn&lt;/code&gt;, because, in order to respect the &lt;a href=&quot;https://doc.rust-lang.org/std/pin/index.html#drop-guarantee&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&lt;/code&gt; drop guarantees&lt;/a&gt;,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*dest&lt;/code&gt; must either be freshly allocated or have had its destructor run just
prior.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since we are constructing into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&lt;/code&gt;ned memory, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor&lt;/code&gt; implementation can
use the address of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*dest&lt;/code&gt; as part of the construction procedure and assume that
that pointer will not suddenly dangle because of a move. This recovers our C++
behavior of “&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this&lt;/code&gt;-stability”.&lt;/p&gt;

&lt;p&gt;Unfortunately, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor&lt;/code&gt; is covered in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe&lt;/code&gt;, and doesn’t even allocate storage
for us. Luckily, it’s not too hard to build our own safe &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::make_unique&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ctor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// First, obtain uninitialized memory on the heap.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uninit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Layout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    
    &lt;span class=&quot;c&quot;&gt;// Then, pin this memory as a MaybeUninit. This memory&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// isn't going anywhere, and MaybeUninit's entire purpose&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// in life is being magicked into existence like this,&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// so this is safe.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pinned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new_unchecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uninit&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.cast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MaybeUninit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Now, perform placement-`new`, potentially FFI'ing into&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// C++.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pinned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;// Because Ctor guarantees it, `uninit` now points to a&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// valid `T`. We can safely stick this in a `Box`. However,&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// the `Box` must be pinned, since we pinned `uninit`&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// earlier.&lt;/span&gt;
    &lt;span class=&quot;nn&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new_unchecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from_raw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uninit&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.cast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Thus, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::make_unique&amp;lt;MyType&amp;gt;()&lt;/code&gt; in C++ becomes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make_box(MyType::new())&lt;/code&gt; in
Rust. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor::ctor&lt;/code&gt; gives us a bridging point to call the C++ constructor from
Rust, in a context where its expectations are respected. For example, we might
write the following binding code:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;C++&quot; file-name=&quot;foo.cc&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Give the constructor an explicit C ABI, using&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// placement-`new` to perform the &quot;rawest&quot; construction&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// possible.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FooCtor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thiz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thiz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot; file-name=&quot;foo_bindings.rs&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ctor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c&quot;&gt;// Declare the placement-new bridge.&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FooCtor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;c&quot;&gt;// Make a new `Ctor` wrapping a &quot;real&quot; closure.&lt;/span&gt;
      &lt;span class=&quot;nn&quot;&gt;ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from_placement_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;move&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// Call back into C++.&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;FooCtor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_mut_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot; file-name=&quot;foo_user.rs&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;foo_bindings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Lo, behold! A C++ type on the Rust heap!&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_box&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But… we’re still on the heap, so we seem to have made no progress. We could
have just called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::make_unique&lt;/code&gt; on the C++ side and shunted it over to Rust.
In particular, this is what &lt;a href=&quot;https://cxx.rs/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cxx&lt;/code&gt;&lt;/a&gt; resorts to for complex types.&lt;/p&gt;

&lt;h2 id=&quot;interlude-i-pinning-on-the-stack&quot;&gt;&lt;a href=&quot;#interlude-i-pinning-on-the-stack&quot;&gt;Interlude I: Pinning on the Stack&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Creating pinned pointers directly requires a sprinkling of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe&lt;/code&gt;.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Box::pin()&lt;/code&gt; allows us to safely create a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, since we know it will
never move, much like the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make_box()&lt;/code&gt; example above. However, it’s not possible
to create a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; to not-necessarilly-&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unpin&lt;/code&gt; data as easilly:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pinned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// Reborrow `ptr` to create a pointer with a shorter lifetime.&lt;/span&gt;
  &lt;span class=&quot;nn&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new_unchecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Once `pinned` goes out of scope, we can move out of `*ptr`!&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moved&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe&lt;/code&gt; block is necessary because of exactly this situation: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt; does
not own its pointee, and a given mutable reference might not be the “oldest”
mutable reference there is. The following &lt;em&gt;is&lt;/em&gt; a safe usage of this constructor:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Intentionally shadow `data` so that no longer-lived reference than&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// the pinned one can be created.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nn&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new_unchecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is such a common pattern in futures code that many futures libraries
provide a macro for performing this kind of pinning on behalf of the user, such
as &lt;a href=&quot;https://docs.rs/tokio/1.4.0/tokio/macro.pin.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tokio::pin!()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With this in hand, we can actually call a constructor on a stack-pinned value:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;MaybeUninit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;uninit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;pin!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.map_unchecked_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_mut_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unfortunately, we &lt;em&gt;still&lt;/em&gt; need to utter a little bit more &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe&lt;/code&gt;, but because
of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor&lt;/code&gt;’s guarantees, this is all perfectly safe; the compiler just can’t
guarantee it on its own. The natural thing to do is to wrap it up in a macro
much like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pin!&lt;/code&gt;, which we’ll call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;emplace!&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;nd&quot;&gt;emplace!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is &lt;em&gt;truly&lt;/em&gt; analogous to C++ stack initialization, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo val(args);&lt;/code&gt;,
although the type of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;val&lt;/code&gt; is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;&amp;amp;mut Foo&amp;gt;&lt;/code&gt;, whereas in C++ it would merely
bee &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo&amp;amp;&lt;/code&gt;. This isn’t much of an obstacle, and just means that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo&lt;/code&gt;’s API on
the Rust side needs to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; for its methods.&lt;/p&gt;

&lt;h2 id=&quot;the-return-value-optimization&quot;&gt;&lt;a href=&quot;#the-return-value-optimization&quot;&gt;The Return Value Optimization&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Now we go to build our Foo-returning function and are immediately hit with a
roadblock:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'wat&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;emplace!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;What is the lifetime &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'wat&lt;/code&gt;? This is just returning a pointer to the current
stack frame, which is no good. In C++ (ignoring fussy defails about move
semantics), NRVO would kick in and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;val&lt;/code&gt; would be constructed “in the return
slot”:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;C++&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MakeFoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/copy_elision&quot;&gt;&lt;em&gt;Return value optimization&lt;/em&gt;&lt;/a&gt; (and the related &lt;em&gt;named return value
optimization&lt;/em&gt;) allow C++ to elide copies when constructing return values. Instead of
constructing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;val&lt;/code&gt; on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MakeFoo&lt;/code&gt;’s stack and then copying it into the ABI’s
return location (be that a register like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rax&lt;/code&gt; or somewhere in the caller’s
stack frame), the value is constructed directly in that location, skipping the
copy. Rust itself performs some limited RVO, though its style of move
semantics makes this a bit less visible.&lt;/p&gt;

&lt;p&gt;Rust does not give us a good way of accessing the return slot directly, for good
reason: it need not have an address! Rust returns all types that look roughly
like a single integer in a register (on modern ABIs), and registers don’t have
addresses. C++ ABIs typically solve this by making types which are
“sufficiently complicated” (usually when they are not trivially moveable) get
passed on the stack unconditionally&lt;sup id=&quot;fnref:unique-ptr-inefficiency&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:unique-ptr-inefficiency&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Since we can’t get at the return slot, we’ll make our own! We just
need to pass the pinned &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; memory that we would pass into
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor::ctor&lt;/code&gt; as a “fake return slot”:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;return_slot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MaybeUninit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nn&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;return_slot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.map_unchecked_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_mut_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is such a common operation that it makes sense to replace
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;&amp;amp;mut MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; with a specific type, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slot&amp;lt;'a, T&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Slot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MaybeUninit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Slot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emplace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ctor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.map_unchecked_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_mut_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;return_slot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Slot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;return_slot&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.emplace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can provide another macro, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slot!()&lt;/code&gt;, which reserves pinned space on the
stack much like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;emplace!()&lt;/code&gt; does, but without the construction step. Calling
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make_foo&lt;/code&gt; only requires minimal ceremony and no user-level &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;nd&quot;&gt;slot!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slot!()&lt;/code&gt; macro is almost identical to &lt;a href=&quot;https://docs.rs/tokio/1.4.0/tokio/macro.pin.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tokio::pin!()&lt;/code&gt;&lt;/a&gt;, except that it
doesn’t initialize the stack space with an existing value.&lt;/p&gt;

&lt;h2 id=&quot;towards-move-constructors-copy-constructors&quot;&gt;&lt;a href=&quot;#towards-move-constructors-copy-constructors&quot;&gt;Towards Move Constructors: Copy Constructors&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Move constructors involve &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/reference#Rvalue_references&quot;&gt;&lt;em&gt;rvalue references&lt;/em&gt;&lt;/a&gt;, which Rust has no meaningful
equivalent for, so we’ll attack the easier version: copy constructors.&lt;/p&gt;

&lt;p&gt;A copy constructor is C++’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clone&lt;/code&gt; equivalent, but, like all constructors, is
allowed to inspect the address of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*this&lt;/code&gt;. Its sole argument is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const T&amp;amp;&lt;/code&gt;,
which has a direct Rust analogue: a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;T&lt;/code&gt;. Let’s write up a trait that captures
this operation:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CopyCtor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;copy_ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MaybeUninit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unlike &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor&lt;/code&gt;, we would implement &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CopyCtor&lt;/code&gt; on the type with the copy
constructor, bridging it to C++ as before. We can then define a helper that
builds a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor&lt;/code&gt; for us:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CopyCtor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ctor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nn&quot;&gt;ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from_placement_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;move&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nn&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;copy_ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;emplace!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;// Calls the copy constructor.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boxed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_box&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Copy onto the heap.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can could (modulo orphan rules) even implement &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CopyCtor&lt;/code&gt; for Rust types 
that implement &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clone&lt;/code&gt; by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clone&lt;/code&gt;ing into the destination.&lt;/p&gt;

&lt;p&gt;It should be straightforward to make a version for move construction… but,
what’s a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&amp;amp;&amp;amp;&lt;/code&gt; in Rust?&lt;/p&gt;

&lt;h2 id=&quot;interlude-ii-unique-ownership&quot;&gt;&lt;a href=&quot;#interlude-ii-unique-ownership&quot;&gt;Interlude II: Unique Ownership&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is interesting, because unlike &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;T&lt;/code&gt;, it is possible to &lt;em&gt;move out&lt;/em&gt; of a
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, since the compiler treats it somewhat magically. There has long been
a desire to introduce a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DerefMove&lt;/code&gt; trait captures this behavior, but the
difficulty is the signature: if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deref&lt;/code&gt; returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;T&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deref_mut&lt;/code&gt; returns
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt;, should &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deref_move&lt;/code&gt; return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt;? Or something… more exotic? You
might not want to dump the value onto the stack; you want &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*x = *y&lt;/code&gt; to not
trigger an expensive intermediate copy, when &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*y: [u8; BIG]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Usually, the “something more exotic” is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;move T&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;own T&lt;/code&gt; reference that
“owns” the pointee, similar to how a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&amp;amp;&amp;amp;&lt;/code&gt; in C++ is taken to mean that the
caller wishes to perform ownership transfer.&lt;/p&gt;

&lt;p&gt;Exotic language features aside, we’d like to be able to implement something like
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DerefMove&lt;/code&gt; for move constructors, since this is the natural analogue of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&amp;amp;&amp;amp;&lt;/code&gt;.
To move out of storage, we need a smart pointer to provide us with three things:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It must actually be a smart pointer (duh).&lt;/li&gt;
  &lt;li&gt;It must be possible to destroy the storage without running the destructor of
the pointee (in Rust, unlike in C++, destructors do not run on moved-from
objects).&lt;/li&gt;
  &lt;li&gt;It must be the &lt;em&gt;unique owner&lt;/em&gt; of the pointee. Formally, if, when &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; goes out
of scope, no thread can access &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*p&lt;/code&gt;, then &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; is the unique owner.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; trivially satisfies all three of these: it’s a smart pointer, we can
destroy the storage using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::alloc::dealloc&lt;/code&gt;, and it satisfies the unique
ownership property.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt; fails both tests: we don’t know how to destory the storage (this is one
of the difficulties with a theoretical &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;move T&lt;/code&gt;) and it is not the unique
owner: some &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt; might outlive it.&lt;/p&gt;

&lt;p&gt;Interestingly, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; only fails the unique ownership test, and it can pass
it dynamically, if we observe the strong and weak counts to both be 1. This
is also true for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Most importantly, however, is that if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;, then it is sufficient that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt;
satisfy these conditions. After all, a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;Box&amp;lt;P&amp;gt;&amp;gt;&lt;/code&gt; uniquely owns its contents,
even if they can’t be moved.&lt;/p&gt;

&lt;p&gt;It’s useful to introduce some traits that record these requirements:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OuterDrop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;outer_drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DerefMove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DerefMut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OuterDrop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OuterDrop&lt;/code&gt; is simply the “outer storage destruction” operation. Naturally, it
is only safe to perform this operation when the pointee’s own destructor has
been separately dropped (there are some subtleties around leaking memory here,
but in general it’s not a good idea to destroy storage without destroying the
pointee, too).&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DerefMove&lt;/code&gt;&lt;sup id=&quot;fnref:deref-move-proposals&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:deref-move-proposals&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt; is the third requirement, which the compiler
cannot check (there’s a lot of these, huh?). Any type which implements
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DerefMove&lt;/code&gt; can be moved out of by carefully dismantling the pointer:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;move_out_of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Target&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;where&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DerefMove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nn&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unpin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Copy the pointee out of `p` (all Rust moves are&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// trivial copies). We need `Unpin` for this to be safe.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    
    &lt;span class=&quot;c&quot;&gt;// Destroy `p`'s storage without running the pointee's&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// destructor.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Make sure to suppress the actual &quot;complete&quot; destructor of&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// `p`.&lt;/span&gt;
    &lt;span class=&quot;nn&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Actually destroy the storage.&lt;/span&gt;
    &lt;span class=&quot;nn&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;outer_drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;c&quot;&gt;// Return the moved pointee, which will be trivially NRVO'ed.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Much like pinning, we need to lift this capability to the stack somehow.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt; won’t cut it here.&lt;/p&gt;

&lt;h2 id=&quot;owning-the-stack&quot;&gt;&lt;a href=&quot;#owning-the-stack&quot;&gt;Owning the Stack&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;We can already speak of uninitialized but uniquely-owned stack memory with
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slot&lt;/code&gt;, but &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slot::emplace()&lt;/code&gt; returns a (pinned) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt;, which cannot be
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DerefMove&lt;/code&gt;. This operation actually loses the uniqueness information of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slot&lt;/code&gt;,
so instead we make &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;emplace()&lt;/code&gt; return a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StackBox&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StackBox&amp;lt;'a, T&amp;gt;&lt;/code&gt; is like a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that’s bound to a stack frame, using a
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slot&amp;lt;'a, T&amp;gt;&lt;/code&gt; as underlying storage. Although it’s just a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut T&lt;/code&gt; on the
inside, it augments it with the uniqueness invariant above. In particular,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StackBox::drop()&lt;/code&gt; is entitled to call the destructor of its pointee in-place.&lt;/p&gt;

&lt;p&gt;To the surprise of no one who has read this far, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StackBox: DerefMove&lt;/code&gt;. The
implementation for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StackBox::outer_drop()&lt;/code&gt; is a no-op, since the calling
convention takes care of destroying stack frames.&lt;/p&gt;

&lt;p&gt;It makes sense that, since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slot::emplace()&lt;/code&gt; returns a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;StackBox&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, so
should &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;emplace!()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;(There’s a crate called &lt;a href=&quot;https://crates.io/crates/stackbox&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stackbox&lt;/code&gt;&lt;/a&gt; that
provides similar &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StackBox&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slot&lt;/code&gt; types, although it is implemented slightly
differently and does not provide the pinning guarantees we need.)&lt;/p&gt;

&lt;h2 id=&quot;move-constructors&quot;&gt;&lt;a href=&quot;#move-constructors&quot;&gt;Move Constructors&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;This is it. The moment we’ve all be waiting for. Behold, the definition of a
move constructor in Rust:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MoveCtor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;move_ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MaybeUninit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;Wait, that’s it?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There’s no such thing as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;move Self&lt;/code&gt;, so, much like
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;drop()&lt;/code&gt;, we have to use a plain ol’ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;mut&lt;/code&gt; instead. Like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Drop&lt;/code&gt;, and like
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CopyCtor&lt;/code&gt;, this function is not called directly by users; instead, we provide
an adaptor that takes in a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MoveCtor&lt;/code&gt; and spits out a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mov&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ctor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;where&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DerefMove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nn&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MoveCtor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;from_placement_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;move&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nn&quot;&gt;MoveCtor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;move_ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

      &lt;span class=&quot;c&quot;&gt;// Destroy `p`'s storage without running the pointee's&lt;/span&gt;
      &lt;span class=&quot;c&quot;&gt;// destructor.&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;nn&quot;&gt;mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;nn&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;outer_drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that we no longer require that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P::Target: Unpin&lt;/code&gt;, since the
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptr::read()&lt;/code&gt; call from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;move_out_of()&lt;/code&gt; is now gone. Instead, we need to make a
specific requirement of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MoveCtor&lt;/code&gt; that I will explain shortly. However, we can
now freely call the move constructor just like any other &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;nd&quot;&gt;emplace!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// Calls the move constructor.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boxed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_box&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// Move onto the heap.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;the-langauge-lawyering-part&quot;&gt;&lt;a href=&quot;#the-langauge-lawyering-part&quot;&gt;The Langauge-Lawyering Part&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;(If you don’t care for language-lawyering, you can skip this part.)&lt;/p&gt;

&lt;p&gt;Ok. We need to justify the loss of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P::Target: Unpin&lt;/code&gt; bound on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov()&lt;/code&gt;,
which seems almost like a contradiction: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; guarantees its pointee won’t
be moved, but isn’t the whole point of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MoveCtor&lt;/code&gt; to perform moves?&lt;/p&gt;

&lt;p&gt;At the begining of this article, I called out the difference between destructive
Rust move and copying C++ moves. The reason that the above isn’t a contradiction
is that the occurences of “move” in that sentence refer to these different
senses of “move”.&lt;/p&gt;

&lt;p&gt;The specific thing that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; is protecting unsafe code from is whatever
state is behind the pointer being blindly &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memcpy&lt;/code&gt; moved to another location,
leaving any self-references in the new location dangling. However, by invoking
a C++-style move constructor, the data never “moves” in the Rust sense; it is
merely copied in a way that carefully preserves any address-dependent state.&lt;/p&gt;

&lt;p&gt;We need to ensure two things:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Implementors of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MoveCtor&lt;/code&gt; for their own type must ensure that their type does
not rely on any pinning guarantees that the move constructor cannot
appropriately “fix up”.&lt;/li&gt;
  &lt;li&gt;No generic code can hold onto a reference to moved-from state, because that
way they could witness whatever messed-up post-destruction state the move
constructor leaves it in.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first of these is passed onto the implementor as an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe impl&lt;/code&gt;
requirement. Designing an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!Unpin&lt;/code&gt; type by hand is difficult, and auto-generated
C++ bindings using this model would hopefully inherit move-correctness from the
C++ code itself.&lt;/p&gt;

&lt;p&gt;The second is more subtle.
In the C++ model, the moved-from value is mutated to mark it as “moved from”,
which usually just inhibits the destructor. C++ believes all destructors are
run for all objects. For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt; sets the moved-from value
to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nullptr&lt;/code&gt;, so that the destructor can be run at the end of scope and do
nothing. Compare with the Rust model, where the compiler inhibits the destructor
automatically through the use of drop flags.&lt;/p&gt;

&lt;p&gt;In order to support move-constructing both Rust and C++ typed through a uniform
interface, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;move_ctor&lt;/code&gt; is a fused destructor/copy operation. In the Rust
case, no “destructor” is run, but in the C++ case we are required to run a
destructor. Although this changes the semantic ordering of destruction compared
to the equivalent C++ program, in practice, no one depends on moved-from objects
actually being destroyed (that I know of).&lt;/p&gt;

&lt;p&gt;After &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;move_ctor&lt;/code&gt; is called, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src&lt;/code&gt; must
be treated as if it had just been destroyed. This means that the storage for
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src&lt;/code&gt; must be disposed of immediately, without running any destructors for the
pointed-to value. Thus, no one must be able to witness the messed-up pinned
state, which is why &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov()&lt;/code&gt; requires &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P: DerefMove&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Thus, no code currently observing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; invariants in unsafe code will notice
anything untoward going on. No destructive moves happen, and no moved-from
state is able to hang around.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;I’m pretty confident this argument is correct, but I’d appreciate some
confirmation. In particular, someone involved in the UCG WG or the
Async WG will have to point out if there are any holes.&lt;/p&gt;

&lt;h2 id=&quot;the-upshot&quot;&gt;&lt;a href=&quot;#the-upshot&quot;&gt;The Upshot&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;In the end, we don’t &lt;em&gt;just&lt;/em&gt; have a move constructors story, but a story for all
kinds of construction, C++-style. Not only that, but we have almost natural
syntax:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;nd&quot;&gt;emplace!&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// The make_box() example above can be added to `Box` through&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// an extension trait.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;emplace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;As far as I can tell, having some kind of “magic” around stack emplacement
is unavoidable; this is a place where the language is unlikely to give us
enough flexibility any time soon, though this concept of constructors is the
first step towards such a thing.&lt;/p&gt;

&lt;p&gt;We can call into C++ from Rust without any heap allocations at all (though
maybe wasting an instruction or two shunting pointers across registers for
our not-RVO):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot; pretty-lang=&quot;Rust&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c&quot;&gt;/// Generated Rust type for bridging to C++, like you might get from `cxx`.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ctor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Slot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StackBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.emplace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.set_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For when dealing with slots explicitly is too much work, types can just be
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctor::mov&lt;/code&gt;ed into a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Box&lt;/code&gt; with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Box::emplace&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I’ve implemented everything discussed in this post in a crate, &lt;a href=&quot;https://crates.io/crates/moveit&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;moveit&lt;/code&gt;&lt;/a&gt;.
Contributions and corrections are welcome.&lt;/p&gt;

&lt;p&gt;A thanks to Manish Goregaokar, Alyssa Haroldson, and Adrian Taylor for feedback
on early versions of this design.&lt;/p&gt;

&lt;h2 id=&quot;future-work&quot;&gt;&lt;a href=&quot;#future-work&quot;&gt;Future Work&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;This is only the beginning: much work needs to be done in type design to have a
good story for bridging move-only types from C++ to Rust, preferably
automatically. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctor&lt;/code&gt;s are merely the theoretical foundation for building a more
ergonomic FFI; usage patterns will likely determine where to go from here.&lt;/p&gt;

&lt;p&gt;Open questions such as “how to containers” remain. Much like C++03’s
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::auto_ptr&lt;/code&gt;, we have no hope of putting a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StackBox&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, and
we’ll need to design a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Vec&lt;/code&gt; variant that knows to call move constructors when
resizing and copy constructors when cloning. There’s also no support for custom
move/copy assignment beyond the trivial &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new (this) auto(that)&lt;/code&gt; pattern, and
it’s unclear whether that’s useful. Do we want to port a constructor-friendly
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashMap&lt;/code&gt; (Rust’s swisstable implementation)? Do we want to come up with macros
that make dealing with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slot&lt;/code&gt; out-params less cumbersome?&lt;/p&gt;

&lt;p&gt;Personally, I’m excited. This feels like a real breakthrough in one of the
biggest questions for true Rust/C++ interop, and I’d like to see what people
wind up building on top of it. ◼&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:cc-replacement&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;This isn’t exactly a &lt;em&gt;universal&lt;/em&gt; opinion &lt;em&gt;glances at Swift&lt;/em&gt; but it is if
you write kernel code like me. &lt;a href=&quot;#fnref:cc-replacement&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:bindgen&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;You can’t just have rustc consume a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.h&lt;/code&gt; and spit out bindings, like e.g.
Go can, but it’s better than the disaster that is JNI. &lt;a href=&quot;#fnref:bindgen&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:relocatable&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;Some WG21 folks have tried to introduce a weaker type-trait,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::is_trivially_relocatable&lt;/code&gt;, which is a weakening of trivally moveable
that permits a Rust-style destructive move. The libc++ implementation of
most STL types, like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;, admit this trait. &lt;a href=&quot;#fnref:relocatable&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:swappy&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;A lot of unsafe Rust code assumes this is the only kind of move. For
example, &lt;a href=&quot;https://doc.rust-lang.org/std/mem/fn.swap.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem::swap()&lt;/code&gt;&lt;/a&gt; is implemented using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memcpy&lt;/code&gt;. This is unlike the
situation in C++, where types will often provide custom &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::swap()&lt;/code&gt;
implementations that preserve type invariants. &lt;a href=&quot;#fnref:swappy&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:pinned-futures&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;Because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; objects collapse their stack state into themselves when
yielding, they may have pointers into themselves (as a stack typically
does). Thus, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;s need to be guaranteed to never move once they begin
executing, since Rust has no move constructors and no way to fix up the
self-pointers. &lt;a href=&quot;#fnref:pinned-futures&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:unique-ptr-inefficiency&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;Among other things, this means that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;s are passed on the
stack, not in a register, which is very wasteful! Rust’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Box&lt;/code&gt; does not have
this issue. &lt;a href=&quot;#fnref:unique-ptr-inefficiency&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:deref-move-proposals&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;Rust has attempted to add something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DerefMove&lt;/code&gt; many times. What’s
described in this post is nowhere near as powerful as a “real” &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DerefMove&lt;/code&gt;
would be, since such a thing would also allow moving &lt;em&gt;into&lt;/em&gt; a memory
location. &lt;a href=&quot;#fnref:deref-move-proposals&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 

</feed>
