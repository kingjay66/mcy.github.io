<!DOCTYPE html> <html lang="en-us"> <head> <link href="http://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Understanding Assembly Part I: RISC-V &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> </head> <body> <div class="sidebar"> <a href="https://mcyoung.xyz/"> <img src="https://mcyoung.xyz/public/avatar.png" alt="Yeah, I drew this. Check out my art blog." class="hide-if-mobile"/> </a> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz/"> mcyoung </a></h1> <p class="lead hide-if-mobile">I'm Miguel. I write about questionable C++ and Rust code. I also have an art blog linked below. </p> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz/">Home</a> • <a class="sidebar-nav-item" href="/about.html">About</a> • <a class="sidebar-nav-item" href="/posts.html">Posts</a> • <a class="sidebar-nav-item" href="/tags.html">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://art.mcyoung.xyz/">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GH</a> • <a class="sidebar-nav-item" href="https://twitter.com/DrawsMiguel">Twt</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/public/resume.pdf">Resumé</a> </nav> <br class="hide-if-mobile"/> <p class="hide-if-mobile">&copy; 2021 Miguel Young de la Sota <br/> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a></p> </div> </div> <div class="content container"><div class="post"> <span class="post-meta"> <span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> <a href="https://mcyoung.xyz/tags.html#toolchains">#toolchains</a> </span> <span> Soon™ </span> </span> <h1 class="post-title"><a href="/wip/understanding-asm-1/"> Understanding Assembly<br/> Part I: RISC-V<br/> </a></h1> <p><a href="https://en.wikipedia.org/wiki/Brainfuck">Brainfuck</a> is a minimalist programming language. Although it is a very simple language, it has a reputation, particularly among beginner or intermediate programmers, as being unapproachable and beyond their capabilities. Even Wikipedia references this in its etymology:</p> <blockquote> <p>The language’s name is a reference to the slang term <em>brainfuck</em>, which refers to things so complicated or unusual that they exceed the limits of one’s understanding.</p> </blockquote> <p>Although brainfuck is a toy, the “assembly language” of computer processors has a similar reputation: difficult, mysterious, and beyond understanding: not something a programmer would use except with extreme self-loathing. Although this view tends to give way as programmers transition from “intermediate” to “advanced”, I feel like there is a missing link for introducing assembly language as a self-contained topic.</p> <p>This series seeks to be that: assuming you have already been using a compiled language like Rust, C++, or Go, how is assembly relevant to you?</p> <blockquote> <p>If you’re here to just learn assembly and don’t really care for motivation, you can just <a href="#diving-in">skip ahead</a>.</p> <p>This series is about learning to <em>understand</em> assembly, not write it. I do occasionally write assembly for a living, but I’m not an <em>expert</em>, and I don’t particularly relish it. I do read a ton of assembly, though.</p> </blockquote> <h2 id="what-is-it-anyways"><a href="#what-is-it-anyways">What Is It, Anyways?</a></h2> <p>As every programmer knows, computers are very stupid. They are very good at following instructions and little else. In fact, the computer is <em>so</em> stupid, it can only process basic instructions serially<sup id="fnref:superscalar" role="doc-noteref"><a href="#fn:superscalar" class="footnote" rel="footnote">1</a></sup>, one by one. The instructions are very simple: “add these two values”, “copy this value from here to there”, “go run these instructions over here”.</p> <p>A computer processor implements these instructions as electronic circuits. At its most basic level, every computer looks like the following program:</p> <figure class="highlight" pretty-lang="Rust"><pre><code class="language-rust" data-lang="rust"><span class="k">loop</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">next_instruction</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">program_counter</span><span class="p">];</span>
  <span class="k">match</span> <span class="n">next_instruction</span> <span class="p">{</span>
    <span class="c">// Figure out what you're supposed to be doing and do it.</span>
  <span class="p">}</span>
  <span class="n">program_counter</span> <span class="o">+=</span> <span class="n">next_instruction</span><span class="nf">.len</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure> <p>The array <code class="language-plaintext highlighter-rouge">program</code> is a your program encoded as a sequence of these “machine instructions” in some kind of binary format. For example, when an Intel x86 processor encounters the value <code class="language-plaintext highlighter-rouge">0x4883d00a</code>, its decoding circuitry decides that this means it should add <code class="language-plaintext highlighter-rouge">10</code> or <code class="language-plaintext highlighter-rouge">11</code> (depending on whether something called the “carry bit” is set) to the “register” <code class="language-plaintext highlighter-rouge">rax</code>.</p> <p>However, if you’re a human programming a computer, writing all of this by hand is… very 60s, and you might prefer to have a textual representation, so you can write this more simply as <code class="language-plaintext highlighter-rouge">adc rax, 10</code>.</p> <p><code class="language-plaintext highlighter-rouge">adc rax, 10</code> is a single line of assembly: it describes a <em>single</em> instruction in text form. Assembly language is “just” a textual representation of the program’s machine code. Your assembler can convert from text into machine instructions, and a <em>dis</em>assembler reverses the process.</p> <h3 id="on-architectures"><a href="#on-architectures">On Architectures</a></h3> <p>There isn’t “an” assembly language. Every computer has a different instruction set architecture, or “ISA”; I use the terms “instruction set”, “architecture”, and “ISA” interchangeably. Each ISA has a corresponding assembly language that describes that ISA’s specific instructions, but they all generally have similar overall structure.</p> <p>I’m going to focus on three ISAs for ease of exposition, introduced in this order:</p> <ol> <li>RISC-V, a modern and fairly simple instruction set (specifically, the rv32gc variant). That’s Part I.</li> <li>x86_64, the instruction set of the device you’re reading this on (unless it’s a phone or Apple M1 laptop). That’s Part II.</li> <li>MOS 6502, a fairly ancient ISA still popular in very small microcontrollers. That’s Part III.</li> </ol> <h2 id="hang-on-why"><a href="#hang-on-why">Hang On, <em>Why</em>?</a></h2> <p>It’s actually very rare to write actual assembly. Thanks to modern (relatively) languages like Rust, C++, and Go, and even things like Haskell and JavaScript, virtually no programmers need to write assembly anymore.</p> <p>But, only because it’s the leading language written by the <em>computers themselves</em>. A compiler’s job is, fundamentally, to write the thee assembly <em>for</em> you. To better understand what a compiler is doing for you, you need to be able to read its output.</p> <p>At this point, it may be worth looking at my <a href="https://mcyoung.xyz//2021/06/01/linker-script/#seriously-whats-a-linker">article on linkers</a> as a refresher on the C compilation model.</p> <p>For example, let’s suppose we have the very simple C program below.</p> <figure class="highlight" pretty-lang="C" file-name="square.c"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">square_and_print</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <p>Clang, my C compiler of choice, can turn it directly into a library via <code class="language-plaintext highlighter-rouge">clang -c square.c</code>. <code class="language-plaintext highlighter-rouge">-c</code> asks the compiler to stop before the link step, outputting the <em>object file</em> <code class="language-plaintext highlighter-rouge">square.o</code>. We can ask the compiler to stop even sooner than that by writing <code class="language-plaintext highlighter-rouge">clang -S square.c</code>, which will output <code class="language-plaintext highlighter-rouge">square.s</code>, the assembly file the compiler produced! For this example, and virtually all others in this post, I’m using a RISC-V target: <code class="language-plaintext highlighter-rouge">-target riscv32-unknown-elf -march=rv32gc</code>.</p> <p>If you build with <code class="language-plaintext highlighter-rouge">-Oz</code> to make the code as small as possible (this makes it easiest to see what’s going on, too), you get something like this:</p> <figure class="highlight" pretty-lang="RISC-V Assembly" file-name="square.s"><pre><code class="language-cpp" data-lang="cpp"><span class="p">.</span><span class="n">text</span>
        <span class="p">.</span><span class="n">file</span>   <span class="s">"square.c"</span>
        <span class="p">.</span><span class="n">globl</span>  <span class="n">square_and_print</span>
<span class="n">square_and_print</span><span class="o">:</span>
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
        <span class="n">sw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">sw</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">mul</span>     <span class="n">s0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span>          <span class="c1">// !</span>
        <span class="n">lui</span>     <span class="n">a0</span><span class="p">,</span> <span class="o">%</span><span class="n">hi</span><span class="p">(.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="o">%</span><span class="n">lo</span><span class="p">(.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="p">)</span>
        <span class="n">mv</span>      <span class="n">a1</span><span class="p">,</span> <span class="n">s0</span>
        <span class="n">call</span>    <span class="n">printf</span>              <span class="c1">// !</span>
        <span class="n">mv</span>      <span class="n">a0</span><span class="p">,</span> <span class="n">s0</span>
        <span class="n">lw</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">lw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">16</span>
        <span class="n">ret</span>

        <span class="p">.</span><span class="n">section</span>        <span class="p">.</span><span class="n">rodata</span>
<span class="p">.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="o">:</span>
        <span class="p">.</span><span class="n">asciz</span>  <span class="s">"%d</span><span class="se">\n</span><span class="s">"</span></code></pre></figure> <p>There’s a lot going on! But pay attention to the two lines with a <code class="language-plaintext highlighter-rouge">!</code>: the first is <code class="language-plaintext highlighter-rouge">mul s0, a0, a0</code>, which is the multiplication <code class="language-plaintext highlighter-rouge">x *= x;</code>. The second is <code class="language-plaintext highlighter-rouge">call printf</code>, which is our function call to <code class="language-plaintext highlighter-rouge">printf()</code>! I’ll explain what everything else means in short order.</p> <p>Writing assembly isn’t a crucial skill, but being able to read it is. It’s actually so useful, that a website exists for quickly generating the assembly output of a vast library of compilers: the <a href="https://godbolt.org/">Compiler Explorer</a>, frequently just called “Godbolt” after its creator, Matt Godbolt. Being able to compare the output of different compilers can help understand what they do! This particular example can be found at <a href="https://godbolt.org/z/ez7d1WzTK">https://godbolt.org/z/ez7d1WzTK</a><sup id="fnref:godbolt-example" role="doc-noteref"><a href="#fn:godbolt-example" class="footnote" rel="footnote">2</a></sup>.</p> <p>“Low-level” languages like C aren’t the only ones where you can inspect assembly output. Godbolt supports Go, for example:</p> <div class="code-multicol" style="height: 300px"> <figure class="highlight" pretty-lang="Go"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">sq</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">SquareAndPrint</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">x</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span></code></pre></figure> <figure class="highlight" pretty-lang="Go-flavored x86 Assembly"><pre><code class="language-shell" data-lang="shell">SquareAndPrint_pc0:
        .file 1 <span class="s2">"&lt;source&gt;"</span>
        .loc 1 5 0
        TEXT    <span class="s2">""</span>.SquareAndPrint<span class="o">(</span>SB<span class="o">)</span>, ABIInternal, <span class="nv">$88</span><span class="nt">-8</span>
        CMPQ    SP, 16<span class="o">(</span>R14<span class="o">)</span>
        PCDATA  <span class="nv">$0</span>, <span class="nv">$-</span>2
        JLS     SquareAndPrint_pc117
        PCDATA  <span class="nv">$0</span>, <span class="nv">$-</span>1
        SUBQ    <span class="nv">$88</span>, SP
        MOVQ    BP, 80<span class="o">(</span>SP<span class="o">)</span>
        LEAQ    80<span class="o">(</span>SP<span class="o">)</span>, BP
        FUNCDATA        <span class="nv">$0</span>, gclocals·69c1753bd5f81501d95132d08af04464<span class="o">(</span>SB<span class="o">)</span>
        FUNCDATA        <span class="nv">$1</span>, gclocals·568470801006e5c0dc3947ea998fe279<span class="o">(</span>SB<span class="o">)</span>
        FUNCDATA        <span class="nv">$2</span>, <span class="s2">""</span>.SquareAndPrint.stkobj<span class="o">(</span>SB<span class="o">)</span>
        FUNCDATA        <span class="nv">$5</span>, <span class="s2">""</span>.SquareAndPrint.arginfo1<span class="o">(</span>SB<span class="o">)</span>
        .loc 1 6 0
        MOVUPS  X15, <span class="s2">""</span>..autotmp_11+64<span class="o">(</span>SP<span class="o">)</span>
        IMULQ   AX, AX
        MOVQ    AX, <span class="s2">""</span>..autotmp_18+56<span class="o">(</span>SP<span class="o">)</span>
        .loc 1 7 0
        PCDATA  <span class="nv">$1</span>, <span class="nv">$1</span>
        CALL    runtime.convT64<span class="o">(</span>SB<span class="o">)</span>
        LEAQ    type.int<span class="o">(</span>SB<span class="o">)</span>, CX
        MOVQ    CX, <span class="s2">""</span>..autotmp_11+64<span class="o">(</span>SP<span class="o">)</span>
        MOVQ    AX, <span class="s2">""</span>..autotmp_11+72<span class="o">(</span>SP<span class="o">)</span>
        NOP
        .file 2 <span class="s2">"</span><span class="nv">$GOROOT</span><span class="s2">/src/fmt/print.go"</span>
        .loc 2 213 0
        MOVQ    os.Stdout<span class="o">(</span>SB<span class="o">)</span>, BX
        LEAQ    go.itab.<span class="k">*</span>os.File,io.Writer<span class="o">(</span>SB<span class="o">)</span>, AX
        LEAQ    go.string.<span class="s2">"%d</span><span class="se">\n</span><span class="s2">"</span><span class="o">(</span>SB<span class="o">)</span>, CX
        MOVL    <span class="nv">$3</span>, DI
        LEAQ    <span class="s2">""</span>..autotmp_11+64<span class="o">(</span>SP<span class="o">)</span>, SI
        MOVL    <span class="nv">$1</span>, R8
        MOVQ    R8, R9
        PCDATA  <span class="nv">$1</span>, <span class="nv">$0</span>
        CALL    fmt.Fprintf<span class="o">(</span>SB<span class="o">)</span>
        .file 3 <span class="s2">"&lt;source&gt;"</span>
        .loc 3 8 0
        MOVQ    <span class="s2">""</span>..autotmp_18+56<span class="o">(</span>SP<span class="o">)</span>, AX
        MOVQ    80<span class="o">(</span>SP<span class="o">)</span>, BP
        ADDQ    <span class="nv">$88</span>, SP
        RET
SquareAndPrint_pc117:
        NOP
        .loc 3 5 0
        PCDATA  <span class="nv">$1</span>, <span class="nv">$-</span>1
        PCDATA  <span class="nv">$0</span>, <span class="nv">$-</span>2
        MOVQ    AX, 8<span class="o">(</span>SP<span class="o">)</span>
        CALL    runtime.morestack_noctxt<span class="o">(</span>SB<span class="o">)</span>
        MOVQ    8<span class="o">(</span>SP<span class="o">)</span>, AX
        PCDATA  <span class="nv">$0</span>, <span class="nv">$-</span>1
        JMP     SquareAndPrint_pc0</code></pre></figure> </div> <p>(I’ve cropped the Go compiler’s output because it is horrifically wordy; it’s also not RISC-V.)</p> <p>Hopefully this is motivation enough to jump into the language proper. It is very useful to have a Godbolt tab open to play around with examples!</p> <h2 id="diving-in"><a href="#diving-in">Diving In</a></h2> <p>So, let’s say you <em>do</em> want to read assembly. How do we do that?</p> <p>Let’s revisit our <code class="language-plaintext highlighter-rouge">square.c</code> example above. This time, I’ve added comments explaining what all the salient parts of the code do, including the <em>assembler directives</em>, which are all of the form <code class="language-plaintext highlighter-rouge">.blah</code>. Note that the <em>actual</em> compiler output includes way more directives that would get in the way of exposition.</p> <p>There’s a lot of terms below that I haven’t defined yet. I’ll break down what this code does gradually, so feel free to refer back to it as necessary, using <a href="#big-example">this handy-dandy link.</a></p> <figure class="highlight" pretty-lang="RISC-V Assembly" file-name="square.s" id="big-example"><pre><code class="language-cpp" data-lang="cpp">        <span class="c1">// This tells the assembler to place all code that</span>
        <span class="c1">// follows in the `.text` section, where executable</span>
        <span class="c1">// data goes.</span>
        <span class="p">.</span><span class="n">text</span>

        <span class="c1">// This is just metadata that tools can use to figure out</span>
        <span class="c1">// how the executable was built.</span>
        <span class="p">.</span><span class="n">file</span>   <span class="s">"square.c"</span>

        <span class="c1">// This asks the assembler to mark `square_and_print`</span>
        <span class="c1">// as an externally linkable symbol. Other files that</span>
        <span class="c1">// refer to `square_and_print` will be able to find it</span>
        <span class="c1">// at link time.</span>
        <span class="p">.</span><span class="n">globl</span>  <span class="n">square_and_print</span>

<span class="n">square_and_print</span><span class="o">:</span> <span class="c1">// This is a label, which gives this position</span>
                  <span class="c1">// in the executable a name that can be</span>
                  <span class="c1">// referenced. They're very similar to `goto`</span>
                  <span class="c1">// labels from C.</span>
                  <span class="c1">//</span>
                  <span class="c1">// We'll see more labels later on.</span>


        <span class="c1">// This is the function prologue, which "sets up" the</span>
        <span class="c1">// function: it allocates stack space and saves the</span>
        <span class="c1">// return address, along with other calling-convention</span>
        <span class="c1">// fussiness.</span>
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
        <span class="n">sw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">sw</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

        <span class="c1">// This is our `x *= x;` from before! Notice that the</span>
        <span class="c1">// compiler rewrote this to `temp = x * x;` at some</span>
        <span class="c1">// point, since the destination register is `s0`.</span>
        <span class="n">mul</span>     <span class="n">s0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span>

        <span class="c1">// These two instructions load the address of a string</span>
        <span class="c1">// constant; this pattern is specific to RISC-V.</span>
        <span class="n">lui</span>     <span class="n">a0</span><span class="p">,</span> <span class="o">%</span><span class="n">hi</span><span class="p">(.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="o">%</span><span class="n">lo</span><span class="p">(.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="p">)</span>
        
        <span class="c1">// This copies the multiplication result into `a1`.</span>
        <span class="n">mv</span>      <span class="n">a1</span><span class="p">,</span> <span class="n">s0</span>

        <span class="c1">// Call to printf!</span>
        <span class="n">call</span>    <span class="n">printf</span>

        <span class="c1">// Move `s0` into `a0`, since it's the return value.</span>
        <span class="n">mv</span>      <span class="n">a0</span><span class="p">,</span> <span class="n">s0</span>

        <span class="c1">// This is the function epilogue, which restores state</span>
        <span class="c1">// saved in the prologue and de-allocates the stack</span>
        <span class="c1">// frame.</span>
        <span class="n">lw</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">lw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">16</span>
        
        <span class="c1">// We're done; return from the function!</span>
        <span class="n">ret</span>

        <span class="c1">// This tells the assembler to place what follows in</span>
        <span class="c1">// the `.rodata` section, for read-only constants like</span>
        <span class="c1">// strings.</span>
        <span class="p">.</span><span class="n">section</span>        <span class="p">.</span><span class="n">rodata</span>

<span class="p">.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="o">:</span> <span class="c1">// Give our string constant a private name. By convention,</span>
        <span class="c1">// .L labels are "private" names emitted by the compiler.</span>

        <span class="c1">// Emit an ASCII string into `.rodata` with an extra null</span>
        <span class="c1">// terminator at the end: that's what the `z` stands for.</span>
        <span class="p">.</span><span class="n">asciz</span>  <span class="s">"%d</span><span class="se">\n</span><span class="s">"</span></code></pre></figure> <h3 id="the-core-syntax"><a href="#the-core-syntax">The Core Syntax</a></h3> <p>All assemblers are different, but the core syntax tends to be the same. There are three main kinds of syntax productions:</p> <ul> <li>Instructions, which consist of a <em>mnemonic</em> followed by some number of <em>operands</em>, such as <code class="language-plaintext highlighter-rouge">addi sp, sp -16</code> and <code class="language-plaintext highlighter-rouge">call printf</code> above. These are the text encoding of machine code.</li> <li>Labels, which consist of a symbol followed by a colon, like <code class="language-plaintext highlighter-rouge">square_and_print:</code> or <code class="language-plaintext highlighter-rouge">.L.str:</code>. These are used to let instruction operands refer to locations in the program.</li> <li>Directives, which vary wildly by assembler. GCC-style assembly like that above uses a <code class="language-plaintext highlighter-rouge">.directive arg, arg</code> syntax, as seen in <code class="language-plaintext highlighter-rouge">.text</code>, <code class="language-plaintext highlighter-rouge">.globl</code>, and <code class="language-plaintext highlighter-rouge">.asciz</code>. They control the behavior of the assembler in various ways.</li> </ul> <p>An assembler’s purpose is to read the <code class="language-plaintext highlighter-rouge">.s</code> file and serialize it as a binary <code class="language-plaintext highlighter-rouge">.o</code> file. It’s kind of like a compiler, but it does virtually no interesting work at all, beyond knowing how to encode instructions.</p> <p>Directives control how this serialization occurs (such as moving around the output cursor); instructions are emitted as-is, and labels refer to locations in the object file. Simple enough, right?</p> <h3 id="anatomy-of-an-instruction"><a href="#anatomy-of-an-instruction">Anatomy of an Instruction</a></h3> <p>Let’s look at the very first instruction in <code class="language-plaintext highlighter-rouge">square_and_print</code>:</p> <figure class="highlight" pretty-lang="RISC-V Assembly"><pre><code class="language-cpp" data-lang="cpp">        <span class="n">addi</span> <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
        <span class="o">----</span> <span class="o">--</span>  <span class="o">--</span>  <span class="o">---</span>
         <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>    <span class="o">|</span>
        <span class="n">mnemonic</span> <span class="o">|</span>   <span class="n">immediate</span> <span class="n">operand</span>
             <span class="o">|</span>  <span class="n">input</span> <span class="n">operand</span>
             <span class="o">|</span>
            <span class="n">output</span> <span class="n">operand</span></code></pre></figure> <p>The first token is called the <em>mnemonic</em>, which is a painfully terse abbreviation of what the instruction does. In this case, <code class="language-plaintext highlighter-rouge">addi</code> means “add with immediate”.</p> <p><code class="language-plaintext highlighter-rouge">sp</code> is a <em>register</em>. Registers are special variables wired directly into the processor that can be used as operands in instructions. The degree to which only registers are permitted as operands varies by architecture; RISC-V only allows registers, but x86, as we’ll see, does not. Registers come in many flavors, but <code class="language-plaintext highlighter-rouge">sp</code> is a GPR, or “general purpose register”; it holds a machine word-sized integer, which in the case of 32-bit RISC-V is… 32-bit<sup id="fnref:whats-a-word" role="doc-noteref"><a href="#fn:whats-a-word" class="footnote" rel="footnote">3</a></sup>.</p> <blockquote> <h4 id="risc-v-registers"><a href="#risc-v-registers">RISC-V Registers</a></h4> <p>RISC-V has a particularly succinct way of specifying registers. It has 32 GPRs names <code class="language-plaintext highlighter-rouge">x0</code> through <code class="language-plaintext highlighter-rouge">x31</code>, but <code class="language-plaintext highlighter-rouge">x0</code> is read-only: writes to it are ignored, and it always reads out a zero.</p> <p>However, each register has an “ABI name” that makes it much clearer what’s going on. <code class="language-plaintext highlighter-rouge">x0</code> is <code class="language-plaintext highlighter-rouge">zero</code>, because that’s what it does. <code class="language-plaintext highlighter-rouge">x1</code>, <code class="language-plaintext highlighter-rouge">x2</code>, <code class="language-plaintext highlighter-rouge">x3</code>, and <code class="language-plaintext highlighter-rouge">x4</code> are called <code class="language-plaintext highlighter-rouge">ra</code>, <code class="language-plaintext highlighter-rouge">sp</code>, <code class="language-plaintext highlighter-rouge">gp</code>, and <code class="language-plaintext highlighter-rouge">tp</code>. The first two are the link register, which holds <u>r</u>eturn <u>a</u>ddresses, and the <u>s</u>tack <u>p</u>ointer. <code class="language-plaintext highlighter-rouge">gp</code> and <code class="language-plaintext highlighter-rouge">tp</code> are the <u>g</u>lobal <u>p</u>pointer and <u>t</u>hread <u>p</u>pointer; we don’t talk about those.</p> <p><code class="language-plaintext highlighter-rouge">x5</code> through <code class="language-plaintext highlighter-rouge">x7</code> are <code class="language-plaintext highlighter-rouge">t0</code> through <code class="language-plaintext highlighter-rouge">t2</code>, and <code class="language-plaintext highlighter-rouge">x28</code> through <code class="language-plaintext highlighter-rouge">x31</code> are <code class="language-plaintext highlighter-rouge">t3</code> through <code class="language-plaintext highlighter-rouge">t6</code>. These are intended for <u>t</u>emporary values. <code class="language-plaintext highlighter-rouge">x8</code>, <code class="language-plaintext highlighter-rouge">x9</code>, and <code class="language-plaintext highlighter-rouge">x18</code> through <code class="language-plaintext highlighter-rouge">x27</code> are <code class="language-plaintext highlighter-rouge">s0</code>, <code class="language-plaintext highlighter-rouge">s1</code>, and <code class="language-plaintext highlighter-rouge">s2</code> through <code class="language-plaintext highlighter-rouge">s11</code>, which are the callee-<u>s</u>aved registers. Finally, <code class="language-plaintext highlighter-rouge">x10</code> through <code class="language-plaintext highlighter-rouge">x17</code> are <code class="language-plaintext highlighter-rouge">a0</code> through <code class="language-plaintext highlighter-rouge">a8</code>, the <u>a</u>rgument registers.</p> <p>The usefulness of these names will be much more apparent when we discuss <a href="#the-calling-convention">the calling convention</a></p> </blockquote> <p><code class="language-plaintext highlighter-rouge">-16</code> is an <em>immediate</em>, which is a literal value that is encoded directly into the instruction. The encoding of <code class="language-plaintext highlighter-rouge">addi sp, sp, -16</code> will include the binary representation of <code class="language-plaintext highlighter-rouge">-16</code> (in the case of RISC-V, as a 12-bit integer). Immediates allow for very small but common integer arguments to be encoded with high locality to the instruction, which is good for code size and performance.</p> <p>The first operand in RISC-V is (almost) always the output. <code class="language-plaintext highlighter-rouge">addi, rd, rs, imm</code> should be read as <code class="language-plaintext highlighter-rouge">rd = rs + imm</code>. Almost all assembler syntax follows this convention, which is called the <a href="https://en.wikipedia.org/wiki/Three-address_code">three-address code</a>; some architectures, like x86, use a “two address” variant instead.</p> <p>Other kinds of operands exist: for example, <code class="language-plaintext highlighter-rouge">call printf</code> refers to the <em>symbol</em> <code class="language-plaintext highlighter-rouge">printf</code>. The assembler, which doesn’t actually know where <code class="language-plaintext highlighter-rouge">printf</code> is, will emit a small note in the object file that tells the linker to find <code class="language-plaintext highlighter-rouge">printf</code> and splat it into the assembly according to some instructions in the note. These notes are called <em>relocations</em>.</p> <p>The instructions <code class="language-plaintext highlighter-rouge">lui a0, %hi(.L.str)</code> and <code class="language-plaintext highlighter-rouge">addi a0, a0, %lo(.L.str)</code> use the <code class="language-plaintext highlighter-rouge">%lo</code> and <code class="language-plaintext highlighter-rouge">%hi</code> operand types, which are specific to RISC-V; they load the low 12 bits and high 20 bits of a symbol’s address into the immediate operand. This is a RISC-V-specific pattern for loading an address into a register, which most assemblers provide with the <em>pseudoinstruction</em> <code class="language-plaintext highlighter-rouge">la a0, .L.str</code> (where <code class="language-plaintext highlighter-rouge">la</code> stands for “load address”).</p> <p>Most architectures have their own funny architecture-specific operand types to deal with the architecture’s idiosyncrasy.</p> <h3 id="types-of-instructions"><a href="#types-of-instructions">Types of Instructions</a></h3> <p>Instructions can be broadly classified into four categories: arithmetic, memory, control flow, and “everything else”<sup id="fnref:vectors-and-floats" role="doc-noteref"><a href="#fn:vectors-and-floats" class="footnote" rel="footnote">4</a></sup>. This is congruent with the basic operations in any other programming language.</p> <p><em>Arithmetic instructions</em> make up the bulk of the instruction set. This always includes addition, subtraction, and bitwise and, or, and xor, as well as unary not and negation. Bit shifts are very common, and multiplication, division, and remainder are <em>usually</em> present, but excluded from smaller devices<sup id="fnref:mul-polyfill" role="doc-noteref"><a href="#fn:mul-polyfill" class="footnote" rel="footnote">5</a></sup>; division in particular is very complex to implement in silicon. There is usually also a “copy” instruction that moves the value of one register to another, which is kind of like a trivial arithmetic instruction. RISC-V calls this <code class="language-plaintext highlighter-rouge">mv</code>.</p> <p>Some architectures also offer more exotic arithmetic. This is just a sampler of what’s available:</p> <ul> <li>Bit rotation, which is like a shift but bits that get shifted off end up at the other end of the integer. This is useful for a vast array of numeric algorithms, including ARX ciphers like <a href="https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant">ChaCha20</a>.</li> <li>Byte reversal, which can be used for changing the endianness of an integer; bit reversal is analogous.</li> <li>Bit extraction, which can be used to form new integers out of bitfields of another.</li> <li>Carry-less multiplication, which is like long multiplication but you don’t bother to carry anything when you add intermediates. This is used to implement <a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">Galois/Counter mode encryption</a>.</li> <li>Fused instructions, like <code class="language-plaintext highlighter-rouge">xnor</code> and <code class="language-plaintext highlighter-rouge">nand</code>.</li> </ul> <p><em>Memory instructions</em> consist of various load and store instructions for fetching memory form RAM into registers, and for writing back to RAM. They usually come in all different sizes for asking the hardware to fetch different kinds of memory.</p> <p>This category also includes instructions necessary for implementing atomics, such as <code class="language-plaintext highlighter-rouge">lock xchg</code> on x86 and <code class="language-plaintext highlighter-rouge">lr</code>/<code class="language-plaintext highlighter-rouge">sc</code> on RISC-V.</p> <p><em>Control flow instructions</em> can be divided into conditional and unconditional jumps. The former are various flavors of <code class="language-plaintext highlighter-rouge">if</code> statement. For example, <code class="language-plaintext highlighter-rouge">beq r1, r2, label</code> will jump to <code class="language-plaintext highlighter-rouge">label</code> if <code class="language-plaintext highlighter-rouge">r1</code> and <code class="language-plaintext highlighter-rouge">r2</code> are equal. The <code class="language-plaintext highlighter-rouge">b</code> stands for “branch”, which is a common name for conditional jumps. Unconditional jumps implement <code class="language-plaintext highlighter-rouge">goto</code> of various flavors; <code class="language-plaintext highlighter-rouge">j label</code> will jump straight to <code class="language-plaintext highlighter-rouge">label</code>, while <code class="language-plaintext highlighter-rouge">jr r1</code> will jump to the dynamic address in <code class="language-plaintext highlighter-rouge">r1</code>. Function call and return instructions are a kind of unconditional jump.</p> <p>Conditional and unconditional jumps can be used together to build loops. For example, to zero a region of memory:</p> <figure class="highlight" pretty-lang="RISC-V Assembly"><pre><code class="language-cpp" data-lang="cpp">        <span class="c1">// Assume a0 is the start of the region, and a1 the</span>
        <span class="c1">// number of bytes to zero.</span>

        <span class="c1">// Set a1 to the end of the region.</span>
        <span class="n">addi</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span>
<span class="n">loop_start</span><span class="o">:</span>
        <span class="c1">// If a0 == a1, we're done!</span>
        <span class="n">beq</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">loop_done</span>

        <span class="c1">// Store a zero byte to `a0` and advance the pointer.</span>
        <span class="n">sb</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
        <span class="n">addi</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">1</span>

        <span class="c1">// Take it from the top!</span>
        <span class="n">j</span> <span class="n">loop_start</span>
<span class="n">loop_done</span><span class="o">:</span></code></pre></figure> <p>“Everything else” is, well… everything else. This includes <code class="language-plaintext highlighter-rouge">nop</code>, which does nothing. No-op instructions can be used to pad space in the instruction stream, provide space for the linker to fix things up later, or implement <a href="https://en.wikipedia.org/wiki/NOP_slide"><code class="language-plaintext highlighter-rouge">nop</code> sleds</a>. There is usually a “breakpoint” instruction, too.</p> <p>This category also includes seldom-used instructions for asking the hardware to do weird stuff, such as <code class="language-plaintext highlighter-rouge">csrrw</code> on RISC-V or <code class="language-plaintext highlighter-rouge">lgdt</code> and <code class="language-plaintext highlighter-rouge">rdmsr</code> on x86. It also usually includes a dedicated syscall instruction for jumping into the kernel, with a name like <code class="language-plaintext highlighter-rouge">ecall</code> or <code class="language-plaintext highlighter-rouge">sysenter</code>.</p> <h2 id="the-calling-convention"><a href="#the-calling-convention">The Calling Convention</a></h2> <p>Functions are the core abstraction of programming. Although processors provide dedicated instructions for jumping into functions and returning from them, they won’t pass arguments and maintain a call stack for you. The <em>calling convention</em> is the part of a platform’s ABI that defines all the ins and outs of how to build this on top of the instruction set.</p> <p>A function call, at the instruction level, is something like the following steps:</p> <ol> <li> <p>Pre-call setup. The caller sets up the function call arguments by placing them in the appointed locations for arguments. These are usually either registers or locations on the stack. a. The caller also saves the <em>caller-saved registers</em> to the stack.</p> </li> <li> <p>Jump to the function. The caller executes a <code class="language-plaintext highlighter-rouge">call</code> instruction (or whatever the function call instruction might be called – virtually all architectures have one). This sets the program counter to the first instruction of the callee.</p> </li> <li> <p>Function prologue. The callee does some setup before executing its code. a. The callee reserves space on the stack in an architecture-dependent manner. b. The callee saves the <em>callee-saved registers</em> to this stack space.</p> </li> <li> <p>Function body. The actual code of the function runs now! This part of the function needs to make sure the return value winds up wherever the <em>return slot</em> for the function is.</p> </li> <li> <p>Function epilogue. The callee undoes whatever work it did in the prologue, such as restoring saved registers, and executes a <code class="language-plaintext highlighter-rouge">ret</code> (or equivalent) instruction to return.</p> </li> </ol> <p>When people say function calls have overhead, this is what they mean. It’s actually a lot of work to get into a function! The bigger the function, usually, the larger this overhead, since more state will need to be saved. Small functions which don’t need to use as many registers can avoid some of the setup, and <em>leaf functions</em> which don’t call any other functions can avoid even more!</p> <p>The main source of overhead is constant: <code class="language-plaintext highlighter-rouge">call</code> and <code class="language-plaintext highlighter-rouge">ret</code>, like all control flow, will slam the breaks on the processor’s pipeline, causing a lot of work to get thrown away.</p> <h3 id="caller-side"><a href="#caller-side">Caller-Side</a></h3> <p>We can see steps 1 and 2 in the call to <code class="language-plaintext highlighter-rouge">printf</code>:</p> <figure class="highlight" pretty-lang="RISC-V Assembly"><pre><code class="language-cpp" data-lang="cpp">        <span class="n">lui</span>     <span class="n">a0</span><span class="p">,</span> <span class="o">%</span><span class="n">hi</span><span class="p">(.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="o">%</span><span class="n">lo</span><span class="p">(.</span><span class="n">L</span><span class="p">.</span><span class="n">str</span><span class="p">)</span>
        <span class="n">mv</span>      <span class="n">a1</span><span class="p">,</span> <span class="n">s0</span>
        <span class="n">call</span>    <span class="n">printf</span></code></pre></figure> <p>Arguments in the usual<sup id="fnref:custom-abis" role="doc-noteref"><a href="#fn:custom-abis" class="footnote" rel="footnote">6</a></sup> RISC-V calling convention, word-sized arguments are passed in the <code class="language-plaintext highlighter-rouge">a0</code> through <code class="language-plaintext highlighter-rouge">a7</code> registers, falling back to passing on the stack if they run out of space. If the argument is too big to fit in a register, it gets passed by reference instead. Arguments that fit into two registers can be split across registers.</p> <p>We can see this in action <a href="#big-example">above</a>. The first argument, a string, is passed by pointer in <code class="language-plaintext highlighter-rouge">a0</code>; <code class="language-plaintext highlighter-rouge">lui</code> and <code class="language-plaintext highlighter-rouge">addi</code> do the work of actually putting that pointer into <code class="language-plaintext highlighter-rouge">a0</code>. The second argument <code class="language-plaintext highlighter-rouge">x</code> is passed in <code class="language-plaintext highlighter-rouge">a1</code>, copied from <code class="language-plaintext highlighter-rouge">s0</code> where it landed from the earlier <code class="language-plaintext highlighter-rouge">mul</code> instruction.</p> <p>Complex function signatures require much more<sup id="fnref:all-args" role="doc-noteref"><a href="#fn:all-args" class="footnote" rel="footnote">7</a></sup> work to set up.</p> <p>This work is all followed by a <code class="language-plaintext highlighter-rouge">call</code>, which hands off to <code class="language-plaintext highlighter-rouge">printf</code> itself. <code class="language-plaintext highlighter-rouge">call</code>’s only job is to jump into the called function, and set the <em>return address</em>, which is how the matching <code class="language-plaintext highlighter-rouge">ret</code> instruction knows how to come back from the function call. On RISC-V, a GPR called <code class="language-plaintext highlighter-rouge">ra</code> is reserved for this task.</p> <h3 id="callee-sidea"><a href="#callee-sidea">Callee-Sidea</a></h3> <p>Meanwhile, steps 3 and 4 occur in <code class="language-plaintext highlighter-rouge">square_and_print</code>’s prologue/epilogue itself:</p> <figure class="highlight" pretty-lang="RISC-V Assembly"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">square_and_print:</span> 
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
        <span class="n">sw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">sw</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

        <span class="c1">// ...</span>

        <span class="n">lw</span>      <span class="n">s0</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">lw</span>      <span class="n">ra</span><span class="p">,</span> <span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">16</span>
        <span class="n">ret</span></code></pre></figure> <p><code class="language-plaintext highlighter-rouge">addi sp, sp, -16</code>, which we stared at so hard above, grows the stack by 16 bytes. <code class="language-plaintext highlighter-rouge">sp</code> is a GPR designated in the calling convention as the <em>stack pointer</em>, which points to the top of the stack at all times. The stack grows downwards (as in most architectures!) and must be aligned to 16-byte boundaries across function calls: even though <code class="language-plaintext highlighter-rouge">square_and_print</code> only uses eight of those bytes, the full 16 bytes must be allocated.</p> <p><code class="language-plaintext highlighter-rouge">sw</code> is a new instruction, meaning “store word”. <code class="language-plaintext highlighter-rouge">sw rs, offset(rd)</code> stores the contents of <code class="language-plaintext highlighter-rouge">rs</code> into the memory location with address <code class="language-plaintext highlighter-rouge">rd + offset</code>. It implements the C statement <code class="language-plaintext highlighter-rouge">rd[offset] = rs;</code>. The two <code class="language-plaintext highlighter-rouge">sw</code> instructions store (or “spill”) the callee-saved registers <code class="language-plaintext highlighter-rouge">ra</code> and <code class="language-plaintext highlighter-rouge">s0</code> to the stack.</p> <p>All registers in RISC-V are caller-saved, except for <code class="language-plaintext highlighter-rouge">ra</code> (the “link register”, which holds the return address) and <code class="language-plaintext highlighter-rouge">s0</code> through <code class="language-plaintext highlighter-rouge">s11</code>. Callee-saved registers are convenient, because they won’t be wiped out by function calls. This is why <code class="language-plaintext highlighter-rouge">square_and_print</code> holds <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">s0</code> and then copies it to <code class="language-plaintext highlighter-rouge">a0</code>: it will need it later (since it’s the return value), and it’s cheaper to leave it in <code class="language-plaintext highlighter-rouge">s0</code> rather than spill it, since the callee will spill it instead if it winds up being necessary. Note that <code class="language-plaintext highlighter-rouge">s1</code> through <code class="language-plaintext highlighter-rouge">s11</code> are <em>not</em> spilled, since <code class="language-plaintext highlighter-rouge">square_and_print</code> doesn’t use them!</p> <p>The epilogue inverts all operations of the prologue in reverse, unspilling registers and shrinking the stack, followed by <code class="language-plaintext highlighter-rouge">ret</code>. On RISC-V, all <code class="language-plaintext highlighter-rouge">ret</code> does is jump to the location referred to by the <code class="language-plaintext highlighter-rouge">ra</code> register. Values are returned the same way as if passing an argument to an unary function: via <code class="language-plaintext highlighter-rouge">a0</code> and <code class="language-plaintext highlighter-rouge">a1</code>, or possibly on the stack via a pointer.</p> <p>Of course, all this work is only necessary to maintain the illusion of a callstack; if <code class="language-plaintext highlighter-rouge">square_and_print</code> were a leaf function, it would not need to spill anything at all! This results in an almost trivial function:</p> <div class="code-multicol"> <figure class="highlight" pretty-lang="C"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <figure class="highlight" pretty-lang="RISC-V Assembly"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// `x` is already in a0, and the</span>
<span class="c1">// return value needs to wind up</span>
<span class="c1">// in a0. EZ!</span>
<span class="n">square</span><span class="o">:</span>
        <span class="n">mul</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span>
        <span class="n">ret</span></code></pre></figure> </div> <p>Because leaf functions won’t call other functions, they won’t need to save the caller-saved <code class="language-plaintext highlighter-rouge">tX</code> registers, so those will see use instead of the <code class="language-plaintext highlighter-rouge">sX</code> registers.</p> <h2 id="the-end-for-now"><a href="#the-end-for-now">The End, for Now</a></h2> <p>Phew! We’re over four thousand words in, so let’s checkpoint what we’ve learned:</p> <ol> <li> <p>Computers are stupid, but can at least follow <em>extremely</em> basic instructions.</p> </li> <li> <p>Assembly language is human-readable version of the instructions a particular computer uses.</p> </li> <li> <p>Assembly language programs consist of <em>instructions</em>, <em>labels</em>, and <em>directives</em>.</p> </li> <li> <p>An instruction is usually written as a <em>mnemonic</em> followed by zero or more <em>operands</em>.</p> </li> <li> <p>Instructions can be broadly categorized as <em>arithmetic</em>, <em>memory</em>, <em>control flow</em>, and “miscellaneous” (plus <em>vector</em> and <em>float</em> instructions for another time).</p> </li> <li> <p><em>Registers</em> hold values the machine is currently operating on.</p> </li> <li> <p>The <em>calling convention</em> describes the low-level interface of a general function, consisting of pre-call setup, and prologues and epilogues in each function.</p> </li> </ol> <p>That’s all for now. RISC-V is a powerful but reasonably simple ISA. Next time, we’ll dive into the much older, much larger, and much complex Intel x86.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:superscalar" role="doc-endnote"> <p>This is a hilarious lie that is beyond the scope of this post. See, for example, <a href="https://en.wikipedia.org/wiki/Superscalar_processor">https://en.wikipedia.org/wiki/Superscalar_processor</a>. <a href="#fnref:superscalar" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:godbolt-example" role="doc-endnote"> <p>You can use this link to play with other RISC-V examples. <a href="#fnref:godbolt-example" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:whats-a-word" role="doc-endnote"> <p>What’s a machine word, exactly? It really depends on context. Most popular architectures has a straight-forward definition: the size of a GPR <em>or</em> the size of a pointer, which are the same.</p> <p>This is not true of all architectures, so beware. <a href="#fnref:whats-a-word" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:vectors-and-floats" role="doc-endnote"> <p>There is one other major category of instructions: so-called <em>vector instructions</em>, which treat their operand registers as vectors that can be operated on component-wise. These are sometimes called single-instruction-multiple-data (SIMD) instructions.</p> <p>Floating point instructions are also usually their own beast, with their own mess of registers. <a href="#fnref:vectors-and-floats" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:mul-polyfill" role="doc-endnote"> <p>Thankfully, these can be polyfilled using the previous ubiquitous instructions. Hacker’s Delight contains all of the relevant algorithms, so I won’t reproduce them here. The division polyfills are particularly interesting. <a href="#fnref:mul-polyfill" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:custom-abis" role="doc-endnote"> <p>The calling convention isn’t actually determined by the architecture in most cases; that’s why it’s called a <em>convention</em>. The convention on x86 actually differs on Windows and Linux, and is usually also language-dependent; C’s calling convention is usually documented, but C++, Rust, and Go invent their own to handle language-specific fussiness.</p> <p>Of course, if you’re writing assembly, you can do whatever you want (though the silicon may be optimized for a particular recommended calling convention).</p> <p>RISC-V defines a recommended calling convention for ELF-based targets: <a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">https://github.com/riscv-non-isa/riscv-elf-psabi-doc</a>. <a href="#fnref:custom-abis" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:all-args" role="doc-endnote"> <p>The following listing shows how all kinds of different arguments are passed. The output isn’t quite what Clang emits, since I’ve cleaned it up for clarity.</p> <div class="code-multicol" style="height: 860px;"> <figure class="highlight" pretty-lang="C"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdnoreturn.h&gt;
</span>
<span class="k">struct</span> <span class="n">Pair</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Triple</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Packed</span> <span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// `noreturn` obviates the</span>
<span class="c1">// {pro,epi}logue in `call_it`.</span>
<span class="n">noreturn</span> <span class="kt">void</span> <span class="nf">all_the_args</span><span class="p">(</span>
  <span class="kt">uint32_t</span> <span class="n">a0</span><span class="p">,</span>
  <span class="kt">uint64_t</span> <span class="n">a1a2</span><span class="p">,</span>
  <span class="k">struct</span> <span class="n">Pair</span> <span class="n">a3a4</span><span class="p">,</span>
  <span class="k">struct</span> <span class="n">Triple</span> <span class="n">a5_by_ref</span><span class="p">,</span>
  <span class="kt">uint16_t</span> <span class="n">a6</span><span class="p">,</span>
  <span class="k">struct</span> <span class="n">Packed</span> <span class="n">a7</span><span class="p">,</span>
  <span class="kt">uint32_t</span> <span class="n">on_the_stack</span><span class="p">,</span>
  <span class="k">struct</span> <span class="n">Triple</span> <span class="n">stack_by_ref</span>
<span class="p">);</span>

<span class="kt">void</span> <span class="nf">call_it</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Pair</span> <span class="n">u</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
  <span class="k">struct</span> <span class="n">Triple</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">15</span><span class="p">};</span>
  <span class="k">struct</span> <span class="n">Packed</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="mi">14</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">};</span>
  <span class="n">all_the_args</span><span class="p">(</span>
    <span class="mi">42</span><span class="p">,</span> <span class="o">-</span><span class="mi">42</span><span class="p">,</span>  <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span>
     <span class="mi">5</span><span class="p">,</span>   <span class="n">w</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="n">v</span>
  <span class="p">);</span>
<span class="p">}</span></code></pre></figure> <figure class="highlight" pretty-lang="RISC-V Assembly"><pre><code class="language-cpp" data-lang="cpp"><span class="nl">call_it:</span>
  <span class="c1">// Reserve stack space.</span>
  <span class="n">addi</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">48</span>

  <span class="c1">// Get `&amp;call_it.v` into `a3`.</span>
  <span class="n">lui</span>     <span class="n">a3</span><span class="p">,</span> <span class="o">%</span><span class="n">hi</span><span class="p">(</span><span class="n">call_it</span><span class="p">.</span><span class="n">v</span><span class="p">)</span>
  <span class="n">addi</span>    <span class="n">a3</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="o">%</span><span class="n">lo</span><span class="p">(</span><span class="n">call_it</span><span class="p">.</span><span class="n">v</span><span class="p">)</span>

  <span class="c1">// Copy contents of `*a3`</span>
  <span class="c1">// into `a0...a2`.</span>
  <span class="n">lw</span>      <span class="n">a0</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>
  <span class="n">lw</span>      <span class="n">a1</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>
  <span class="n">lw</span>      <span class="n">a2</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>

  <span class="c1">// Create two copies of `v`</span>
  <span class="c1">// on the stack to pass by</span>
  <span class="c1">// reference.</span>

  <span class="c1">// This is `a5_by_ref`.</span>
  <span class="n">sw</span>      <span class="n">a2</span><span class="p">,</span> <span class="mi">40</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
  <span class="n">sw</span>      <span class="n">a1</span><span class="p">,</span> <span class="mi">36</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
  <span class="n">sw</span>      <span class="n">a0</span><span class="p">,</span> <span class="mi">32</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

  <span class="c1">// This is `stack_by_ref`.</span>
  <span class="n">sw</span>      <span class="n">a2</span><span class="p">,</span> <span class="mi">24</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
  <span class="n">sw</span>      <span class="n">a2</span><span class="p">,</span> <span class="mi">20</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
  <span class="n">sw</span>      <span class="n">a0</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
  
  <span class="c1">// Load the argument regs.</span>
  <span class="n">addi</span>    <span class="n">a0</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">42</span>
  <span class="n">addi</span>    <span class="n">a1</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="o">-</span><span class="mi">42</span>
  <span class="n">addi</span>    <span class="n">a2</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
  <span class="n">addi</span>    <span class="n">a3</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">7</span>
  <span class="n">addi</span>    <span class="n">a4</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">9</span>
  <span class="c1">// A pointer to `a5_by_ref`!</span>
  <span class="n">addi</span>    <span class="n">a5</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">addi</span>    <span class="n">a6</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">5</span>
  <span class="c1">// Note that `a7` is three</span>
  <span class="c1">// packed bytes!</span>
  <span class="n">lui</span>     <span class="n">a0</span><span class="p">,</span> <span class="mi">289</span>
  <span class="n">addi</span>    <span class="n">a7</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">14</span>

  <span class="c1">// Store `21` on the top of</span>
  <span class="c1">// the stack (our "a8")</span>
  <span class="n">addi</span>    <span class="n">t0</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">21</span>
  <span class="n">sw</span>      <span class="n">t0</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

  <span class="c1">// Store a pointer to</span>
  <span class="c1">// `stack_by_ref` on the </span>
  <span class="c1">// second spot from the</span>
  <span class="c1">// stack top (our "a9")</span>
  <span class="n">addi</span>    <span class="n">t0</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">16</span>
  <span class="n">sw</span>      <span class="n">t0</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

  <span class="c1">// Call it!</span>
  <span class="n">call</span>    <span class="n">all_the_args</span>

<span class="n">callit</span><span class="p">.</span><span class="n">v</span><span class="o">:</span>
  <span class="c1">// The constant `{11, 13, 15}`.</span>
  <span class="p">.</span><span class="n">word</span>   <span class="mi">11</span>
  <span class="p">.</span><span class="n">word</span>   <span class="mi">13</span>
  <span class="p">.</span><span class="n">word</span>   <span class="mi">15</span></code></pre></figure> </div> <p><a href="#fnref:all-args" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <a href="/2021/06/01/linker-script/"> <small class="post-meta-flat">2021-06-01</small> Everything You Never Wanted To Know About Linker Script </a> <li> <a href="/2021/05/24/ptr-taxonomy/"> <small class="post-meta-flat">2021-05-24</small> The Taxonomy of Pointers </a> <li> <a href="/2021/04/26/move-ctors/"> <small class="post-meta-flat">2021-04-26</small> Move Constructors in Rust: Is it possible? </a> </ul> </div> </div> </body> <div class="sidebar show-if-mobile"> <div class="container sidebar-sticky"> &copy; 2021 Miguel Young de la Sota <br/> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> </div> </div> </html>