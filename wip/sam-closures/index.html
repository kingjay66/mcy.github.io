<!DOCTYPE html> <html lang="en-us"> <head> <link href="http://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Single Abstract Method Traits &middot; mcyoung </title> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/syntax.css"> <link rel="stylesheet" href="https://mcyoung.xyz/public/css/style.css"> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"> <link rel="shortcut icon" href="https://mcyoung.xyz/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <script src="https://mcyoung.xyz/public/js/minimap.js"></script> </head> <body> <div class="sidebar"> <a href="https://mcyoung.xyz/"> <img src="https://mcyoung.xyz/public/avatar.png" alt="Yeah, I drew this. Check out my art blog." class="hide-if-mobile"/> </a> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1><a href="https://mcyoung.xyz/"> mcyoung </a></h1> <p class="lead hide-if-mobile">I'm Miguel. I write about questionable C++ and Rust code. I also have an art blog linked below. </p> </div> <hr class="hide-if-mobile"/> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://mcyoung.xyz/">Home</a> • <a class="sidebar-nav-item" href="/about.html">About</a> • <a class="sidebar-nav-item" href="/posts.html">Posts</a> • <a class="sidebar-nav-item" href="/tags.html">Tags</a> </nav> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="https://art.mcyoung.xyz/">Art</a> • <a class="sidebar-nav-item" href="https://github.com/mcy">GH</a> • <a class="sidebar-nav-item" href="https://twitter.com/DrawsMiguel">Twt</a> • <a class="sidebar-nav-item" href="https://mcyoung.xyz/public/resume.pdf">Resumé</a> </nav> <br class="hide-if-mobile"/> <p class="hide-if-mobile">&copy; 2023 Miguel Young de la Sota <br/> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a></p> </div> </div> <div class="content container"><div class="post"> <span class="post-meta"> <span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> </span> <span> Soon™ </span> </span> <h1 class="post-title"><a href="/wip/sam-closures/"> Single Abstract Method Traits </a></h1> <p>Rust and C++ both have very similar operational semantics for their “anonymous function” expressions (they call them “closures” and “lambdas” respectively; I will use these interchangably). Here’s what those expressions look like.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">square</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">square</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The type of <code class="language-plaintext highlighter-rouge">square</code> in both versions is an anonymous type that holds the captures for that closure. In C++, this type provides an <code class="language-plaintext highlighter-rouge">operator()</code> member that can be used to call it, wheras in Rust, it implements <code class="language-plaintext highlighter-rouge">FnOnce</code> (and possibly <code class="language-plaintext highlighter-rouge">FnMut</code> and <code class="language-plaintext highlighter-rouge">Fn</code>, depending on the captures), which represent a “callable” object.</p> <blockquote> <p>For the purposes of this article, I am going to regard “function item values” as being identical to closures that explicitly specify their inputs and outputs for all intents and purposes. This is not completely accurate, because when I write <code class="language-plaintext highlighter-rouge">let x = drop;</code>, the resulting object is generic, but whenever I say “a closure” in Rust, I am also including these closure-like types too.</p> </blockquote> <p>There is one thing C++ closures can express which Rust closures can’t: you can’t create a “generic” closure in Rust. In particular, in C++ we can write this code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fn</span><span class="p">&gt;</span>
<span class="kt">size_t</span> <span class="nf">CallMany</span><span class="p">(</span><span class="n">Fn</span> <span class="n">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">{</span><span class="mi">5</span><span class="p">})</span> <span class="o">+</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"foo"</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">CallMany</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">auto</code> keyword in a closure in C++ does not work like in Rust. In Rust, if try to write “equivalent” code, <code class="language-plaintext highlighter-rouge">let x = |val| val.len();</code>, on its own, we get this error:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0282</span><span class="p">]:</span> <span class="k">type</span> <span class="n">annotations</span> <span class="n">needed</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">12</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>            <span class="o">^^^</span>  <span class="o">---</span> <span class="k">type</span> <span class="n">must</span> <span class="n">be</span> <span class="n">known</span> <span class="n">at</span> <span class="n">this</span> <span class="n">point</span>
  <span class="p">|</span>
<span class="n">help</span><span class="p">:</span> <span class="n">consider</span> <span class="n">giving</span> <span class="n">this</span> <span class="n">closure</span> <span class="n">parameter</span> <span class="n">an</span> <span class="n">explicit</span> <span class="k">type</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">:</span> <span class="cm">/* Type */</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>               <span class="o">++++++++++++</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is because in Rust, a closure argument without a type annotation means “please deduce what this should be”, so it participates in Rust’s type inference, wheras in C++ an <code class="language-plaintext highlighter-rouge">auto</code> argument means “make this a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>”.</p> <p>How would we implement <code class="language-plaintext highlighter-rouge">CallMany</code> in Rust, anyways? We could try but we quickly hit a problem:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">???</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>What should we put in the <code class="language-plaintext highlighter-rouge">???</code>? It can’t be a type parameter of <code class="language-plaintext highlighter-rouge">call_many</code>, since that has a concrete value in the body of the function. We want to say that <code class="language-plaintext highlighter-rouge">Fn</code> can accept <em>any</em> argument that implements <code class="language-plaintext highlighter-rouge">len</code>. There isn’t even syntax to describe this, but you could imagine adding a version of <code class="language-plaintext highlighter-rouge">for&lt;...&gt;</code> that works on types, and write something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="k">for</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Len</span><span class="o">&gt;</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The imaginary syntax <code class="language-plaintext highlighter-rouge">for&lt;T: Len&gt; Fn(&amp;T) -&gt; usize</code> means “implements <code class="language-plaintext highlighter-rouge">Fn</code> for all <em>all</em> types <code class="language-plaintext highlighter-rouge">T</code> that implement <code class="language-plaintext highlighter-rouge">Len</code>”. This is a pretty intense thing to ask rustc to prove. It is not unachievable, but it would be hard to implement.</p> <blockquote> <p>For the purposes of this article, I am going to consider <code class="language-plaintext highlighter-rouge">for&lt;T&gt;</code> a plausible, if unlikely, language feature. I will neither assume it will ever happen, nor that we should give up on ever having it. This “middle of uncertainty” is important to ensure that we do not <em>make</em> adding this feature impossible in the discussion that follows.</p> </blockquote> <h2 id="a-workaround"><a href="#a-workaround">A Workaround</a></h2> <p>Let’s examine the <code class="language-plaintext highlighter-rouge">Fn</code> trait, greatly simplified.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="n">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">Fn::call</code> is analogous to <code class="language-plaintext highlighter-rouge">operator()</code> in C++. When we say that we want a “generic closure”, we mean that we want to instead have a trait that looks a bit more like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="n">Fn</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">fn</span> <span class="n">call</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Notice how <code class="language-plaintext highlighter-rouge">Args</code> has moved from being a trait parameter to being a function parameter, and <code class="language-plaintext highlighter-rouge">Output</code> now depends on it. This is a slightly different formulation from what we described above, because we are no longer demanding an infinitude of trait implementations, but now the implementation of one trait with a generic method.</p> <p>For our specific example, we want something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Callback</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This compiles and expresses what we want precisely: we want to call <code class="language-plaintext highlighter-rouge">f</code> on arbitrary <code class="language-plaintext highlighter-rouge">impl Len</code> types.</p> <p>But how do we call <code class="language-plaintext highlighter-rouge">call_many</code>? That starts to get pretty ugly.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">CbImpl</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">CbImpl</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">val</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="n">CbImpl</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This has the potential to get really, really ugly. I used this pattern for a non-allocating visitor I wrote recently, and it wasn’t pretty. I had to write a macro to cut down on the boilerplate.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">resume_by</span> <span class="p">{</span>
  <span class="p">(</span><span class="nv">$parser:expr</span><span class="p">,</span> <span class="nv">$cb:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{{</span>
    <span class="k">struct</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">parser</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">start</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="n">Resume</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">resume</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">visitor</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">impl</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.parser</span><span class="nf">.do_with_rewind</span><span class="p">(</span>
          <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.start</span><span class="p">,</span>
          <span class="p">||</span> <span class="p">(</span><span class="nv">$cb</span><span class="p">)(</span><span class="k">self</span><span class="py">.parser</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">visitor</span><span class="p">),</span>
        <span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Cb</span> <span class="p">{</span> <span class="n">parser</span><span class="p">:</span> <span class="nv">$parser</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">None</span> <span class="p">}</span>
  <span class="p">}};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This macro is, unsurprisingly, quite janky. It also can’t really do captures, because the <code class="language-plaintext highlighter-rouge">$cb</code> argument that contains the actual code is buried inside of a nested <code class="language-plaintext highlighter-rouge">impl</code>.</p> <p>You might think “well Miguel, why don’t you hoist <code class="language-plaintext highlighter-rouge">$cb</code> into the <code class="language-plaintext highlighter-rouge">Cb</code> struct?” The problem is now that I need to write <code class="language-plaintext highlighter-rouge">impl&lt;'s, F: FnMut(&amp;Parser&lt;'s&gt;, ???)&gt;</code> so that I can actually call the callback in the body of <code class="language-plaintext highlighter-rouge">Resume::resume</code>, but that brings us back to our trait bound problem from the start!</p> <p>This is a general problem with this type of solution: there is no macro you can write that will capture an arbitrary closure to implement a trait by calling that closure, if the method being implemented is generic, because if you <em>could</em>, I wouldn’t have to bother with the macro.</p> <h2 id="lets-talk-about-java"><a href="#lets-talk-about-java">Let’s Talk About Java</a></h2> <p>Historically, the way you would pass code as an argument in Java would be to do something like</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callback</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">runMyThing</span><span class="o">(</span><span class="nc">Callback</span> <span class="n">cb</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">cb</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">runMyThing</span><span class="o">(</span><span class="k">new</span> <span class="nc">Callback</span><span class="o">()</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="n">arg</span><span class="o">;</span> <span class="o">}</span>
<span class="o">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">new Type() {...}</code> syntax would mint a new class on the spot, using the code in between the braces to provide implementations of abstract methods.</p> <p>Java 8 introduced lambdas to Java, with the syntax <code class="language-plaintext highlighter-rouge">x -&gt; expr</code>, and they wanted to be compatible with this existing code. So they built what I have come to regard a masterclass in language design.</p> <p>There are is no language-blessed <code class="language-plaintext highlighter-rouge">Function</code> interface. Instead, <em>any</em> interface with exactly one abstract method can be initialized from a lambda expression. These are called single abstract method (SAM) interfaces.</p> <p>So, without needing to touch the existing library, I can turn the <code class="language-plaintext highlighter-rouge">new</code> syntax into this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">runMyThing</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p><em>chef’s kiss</em></p> <p>Mind, Java <em>does</em> provide a mess of “standard function interfaces” in the <code class="language-plaintext highlighter-rouge">java.util.functional</code> package, and quite a bit of the standard library uses them, but they don’t need to express the totality of functions you might want to capture as objects.</p> <p>These “SAM closures” give closures a powerful “BYO interface” aspect. Lambdas in Java are not “function objects”, they are extremely lightweight anonymous classes the pertinent interface.</p> <p>I think this can let us cut the gordian knot of generic closures in Rust.</p> <h2 id="sam-in-rust"><a href="#sam-in-rust">SAM in Rust</a></h2> <p>In what remains I will propose how we can extend the traits that closures implement to be <em>any</em> SAM trait, in addition to the traits they implement ipso facto.</p> <p>What’s a SAM trait in Rust? It’s any trait <code class="language-plaintext highlighter-rouge">T</code> with precisely ONE method that does not have a default implementation with the following properties:</p> <ol> <li>It must have a <code class="language-plaintext highlighter-rouge">self</code> parameter with type <code class="language-plaintext highlighter-rouge">Self</code>, <code class="language-plaintext highlighter-rouge">&amp;Self</code>, or <code class="language-plaintext highlighter-rouge">&amp;mut Self</code>.</li> <li>It does not mention <code class="language-plaintext highlighter-rouge">Self</code> in any part of its argument types, its return type, or its <code class="language-plaintext highlighter-rouge">where</code> clauses, except for the <code class="language-plaintext highlighter-rouge">self</code> parameter.</li> <li>Has no associated consts or types, or is one of the <code class="language-plaintext highlighter-rouge">Fn</code> traits.</li> <li>There are no blanket <code class="language-plaintext highlighter-rouge">impl</code>s of this trait.</li> </ol> <blockquote> <p>In addition to the <code class="language-plaintext highlighter-rouge">Fn</code> traits, closures automatically implement <code class="language-plaintext highlighter-rouge">Clone</code>, <code class="language-plaintext highlighter-rouge">Copy</code>, <code class="language-plaintext highlighter-rouge">Send</code>, and <code class="language-plaintext highlighter-rouge">Sync</code> as appropriate. We can safely ignore this automatic impl generation.</p> </blockquote> <p>Then, a closure type <code class="language-plaintext highlighter-rouge">C</code> is said to implement <code class="language-plaintext highlighter-rouge">T</code> if its body, before type inference occurs, could be used to implement this unique abstract methodl, transforming captures into <code class="language-plaintext highlighter-rouge">self.field</code> accesses in the expected way (in fact, in the <em>exact way</em> in which a <code class="language-plaintext highlighter-rouge">Fn</code> impl is generated).</p> <p>This means that I could just write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We need (1) above, since the method needs to match to one of <code class="language-plaintext highlighter-rouge">Fn</code>, <code class="language-plaintext highlighter-rouge">FnMut</code>, or <code class="language-plaintext highlighter-rouge">FnOnce</code>’s methods.</p> <p>We requite (2) because it is virtually impossible to name a closure within itself without greating a type of infinite size. It is better to not worry about the consequences of any of this.</p> <p>We require (3) because inferring associated consts is impossible, and I don’t want to try to specify a way by which we can infer associated types, which the <code class="language-plaintext highlighter-rouge">Fn</code> traits are simple enough to be able to do on their own.</p> <p>We require (4) because we do not want to get a situation like the following:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">T1</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">T2</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">T1</span><span class="o">&gt;</span> <span class="n">T2</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"not actually gonna call T1::foo() lmao"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
<span class="nn">T2</span><span class="p">::</span><span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c">// What should this print?</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>If the type of <code class="language-plaintext highlighter-rouge">x</code> implements <code class="language-plaintext highlighter-rouge">T2</code> directly, we print <code class="language-plaintext highlighter-rouge">"hello"</code>, but if we decide it implements <code class="language-plaintext highlighter-rouge">T1</code> instead, it doesn’t, because we get the blanket impl. If it decides it should implement both… we get a coherence violation.</p> <h3 id="soooo-what-does-this-do-to-type-inference"><a href="#soooo-what-does-this-do-to-type-inference">Soooo… What does this do to type inference?</a></h3> <p>Ok, that seems easy, right? Unfortunately we need to face up with the usual problem of type inference in Rust: because inference is a constraint solver, we need to make sure we do not accidentally change the constraints the type checker sees that would cause it to cause existing code to break or infer different types.</p> <p>When I write a closure with elided type annotations, the compiler will try to produce a unique answer for what those annotations are.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="mi">5</span><span class="p">;</span>
<span class="nn">f</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
<span class="nn">f</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span> <span class="c">// error: type mismatch in closure arguments</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>I was also somewhat hand-wavy when I said “before type inference occurs, could be used to implement this unique abstract method”. This is effectively asking for a compiler-generated impl to be minted only when a particular interpretation of the closure’s input and output types can be uniquely chosen to make the body type-check.</p> <p>This gets worse when you realize that a closure can influence the types of things outside of it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnMut</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
<span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">v</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="nn">f</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
<span class="nn">f</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Now whatever we pick for <code class="language-plaintext highlighter-rouge">x</code> influences the type of <code class="language-plaintext highlighter-rouge">v</code>. This gives closures a slightly “macro” quality, because dependning on which trait a closure is called through, it might have different behavior depending on how type inference worked out.</p> <p>I think this particular problem can be worked around by declaring that a closure can only be called upon to implement exactly one trait via this mechanism (up to potentially capturing generic parameters as in the code below).</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">convert_to</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Into</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
  <span class="p">||</span> <span class="n">x</span><span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>(We need to make an exception for <code class="language-plaintext highlighter-rouge">FnOnce</code>, <code class="language-plaintext highlighter-rouge">FnMut</code>, and <code class="language-plaintext highlighter-rouge">Fn</code>, which are automatically implemented together; these traits are well-understood by the compiler so it should not pose an issue.)</p> <p>Now, I don’t think this problem kills the idea, but it does mean we need to be very careful that it does not change type inference. I am not an expert on precisely how inference around closures works, so I’m mostly hoping that there isn’t some existing use-case that makes this categorically impossible.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Generic lambdas are extremely powerful in C++, and allow for very slick API designs; I often miss them in Rust. Although it feels like there is an insurmountable obstruction, I hope that the SAM interface approach offers a simpler, and possibly more pragmatic, approach to making them work in Rust.</p> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <a href="/2023/04/04/trait-rez-wishlist/"> <small class="post-meta-flat">2023-04-04</small> Better Trait Resolution in Rust </a> <li> <a href="/2023/03/29/rseq-checkout/"> <small class="post-meta-flat">2023-03-29</small> Atomicless Concurrency </a> <li> <a href="/2022/07/24/curta/"> <small class="post-meta-flat">2022-07-24</small> 3Hz Computer, Hold the Transistors </a> </ul> </div> <div class="minimap"> <div class="minimap-size"></div> <div class="minimap-controller"></div> <div class="minimap-content"> <div class="content container"> <div class="post"> <span class="post-meta"> <span> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> <a href="https://mcyoung.xyz/tags.html#language-design">#language-design</a> </span> <span> Soon™ </span> </span> <h1 class="post-title"><a href="/wip/sam-closures/"> Single Abstract Method Traits </a></h1> <p>Rust and C++ both have very similar operational semantics for their “anonymous function” expressions (they call them “closures” and “lambdas” respectively; I will use these interchangably). Here’s what those expressions look like.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">square</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="n">square</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The type of <code class="language-plaintext highlighter-rouge">square</code> in both versions is an anonymous type that holds the captures for that closure. In C++, this type provides an <code class="language-plaintext highlighter-rouge">operator()</code> member that can be used to call it, wheras in Rust, it implements <code class="language-plaintext highlighter-rouge">FnOnce</code> (and possibly <code class="language-plaintext highlighter-rouge">FnMut</code> and <code class="language-plaintext highlighter-rouge">Fn</code>, depending on the captures), which represent a “callable” object.</p> <blockquote> <p>For the purposes of this article, I am going to regard “function item values” as being identical to closures that explicitly specify their inputs and outputs for all intents and purposes. This is not completely accurate, because when I write <code class="language-plaintext highlighter-rouge">let x = drop;</code>, the resulting object is generic, but whenever I say “a closure” in Rust, I am also including these closure-like types too.</p> </blockquote> <p>There is one thing C++ closures can express which Rust closures can’t: you can’t create a “generic” closure in Rust. In particular, in C++ we can write this code.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fn</span><span class="p">&gt;</span>
<span class="kt">size_t</span> <span class="nf">CallMany</span><span class="p">(</span><span class="n">Fn</span> <span class="n">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">{</span><span class="mi">5</span><span class="p">})</span> <span class="o">+</span> <span class="n">fn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"foo"</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">CallMany</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">C++</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">auto</code> keyword in a closure in C++ does not work like in Rust. In Rust, if try to write “equivalent” code, <code class="language-plaintext highlighter-rouge">let x = |val| val.len();</code>, on its own, we get this error:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0282</span><span class="p">]:</span> <span class="k">type</span> <span class="n">annotations</span> <span class="n">needed</span>
 <span class="o">-</span><span class="k">-&gt;</span> <span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">12</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>            <span class="o">^^^</span>  <span class="o">---</span> <span class="k">type</span> <span class="n">must</span> <span class="n">be</span> <span class="n">known</span> <span class="n">at</span> <span class="n">this</span> <span class="n">point</span>
  <span class="p">|</span>
<span class="n">help</span><span class="p">:</span> <span class="n">consider</span> <span class="n">giving</span> <span class="n">this</span> <span class="n">closure</span> <span class="n">parameter</span> <span class="n">an</span> <span class="n">explicit</span> <span class="k">type</span>
  <span class="p">|</span>
<span class="mi">4</span> <span class="p">|</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">|</span><span class="n">val</span><span class="p">:</span> <span class="cm">/* Type */</span><span class="p">|</span> <span class="n">val</span><span class="nf">.len</span><span class="p">();</span>
  <span class="p">|</span>               <span class="o">++++++++++++</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This is because in Rust, a closure argument without a type annotation means “please deduce what this should be”, so it participates in Rust’s type inference, wheras in C++ an <code class="language-plaintext highlighter-rouge">auto</code> argument means “make this a template parameter of <code class="language-plaintext highlighter-rouge">operator()</code>”.</p> <p>How would we implement <code class="language-plaintext highlighter-rouge">CallMany</code> in Rust, anyways? We could try but we quickly hit a problem:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">???</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>What should we put in the <code class="language-plaintext highlighter-rouge">???</code>? It can’t be a type parameter of <code class="language-plaintext highlighter-rouge">call_many</code>, since that has a concrete value in the body of the function. We want to say that <code class="language-plaintext highlighter-rouge">Fn</code> can accept <em>any</em> argument that implements <code class="language-plaintext highlighter-rouge">len</code>. There isn’t even syntax to describe this, but you could imagine adding a version of <code class="language-plaintext highlighter-rouge">for&lt;...&gt;</code> that works on types, and write something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="k">for</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Len</span><span class="o">&gt;</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="nf">f</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="nf">f</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>The imaginary syntax <code class="language-plaintext highlighter-rouge">for&lt;T: Len&gt; Fn(&amp;T) -&gt; usize</code> means “implements <code class="language-plaintext highlighter-rouge">Fn</code> for all <em>all</em> types <code class="language-plaintext highlighter-rouge">T</code> that implement <code class="language-plaintext highlighter-rouge">Len</code>”. This is a pretty intense thing to ask rustc to prove. It is not unachievable, but it would be hard to implement.</p> <blockquote> <p>For the purposes of this article, I am going to consider <code class="language-plaintext highlighter-rouge">for&lt;T&gt;</code> a plausible, if unlikely, language feature. I will neither assume it will ever happen, nor that we should give up on ever having it. This “middle of uncertainty” is important to ensure that we do not <em>make</em> adding this feature impossible in the discussion that follows.</p> </blockquote> <h2 id="a-workaround"><a href="#a-workaround">A Workaround</a></h2> <p>Let’s examine the <code class="language-plaintext highlighter-rouge">Fn</code> trait, greatly simplified.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="n">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p><code class="language-plaintext highlighter-rouge">Fn::call</code> is analogous to <code class="language-plaintext highlighter-rouge">operator()</code> in C++. When we say that we want a “generic closure”, we mean that we want to instead have a trait that looks a bit more like this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">trait</span> <span class="n">Fn</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">fn</span> <span class="n">call</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Notice how <code class="language-plaintext highlighter-rouge">Args</code> has moved from being a trait parameter to being a function parameter, and <code class="language-plaintext highlighter-rouge">Output</code> now depends on it. This is a slightly different formulation from what we described above, because we are no longer demanding an infinitude of trait implementations, but now the implementation of one trait with a generic method.</p> <p>For our specific example, we want something like this.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Len</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Callback</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This compiles and expresses what we want precisely: we want to call <code class="language-plaintext highlighter-rouge">f</code> on arbitrary <code class="language-plaintext highlighter-rouge">impl Len</code> types.</p> <p>But how do we call <code class="language-plaintext highlighter-rouge">call_many</code>? That starts to get pretty ugly.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">CbImpl</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">CbImpl</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Len</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">val</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(</span><span class="n">CbImpl</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This has the potential to get really, really ugly. I used this pattern for a non-allocating visitor I wrote recently, and it wasn’t pretty. I had to write a macro to cut down on the boilerplate.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">resume_by</span> <span class="p">{</span>
  <span class="p">(</span><span class="nv">$parser:expr</span><span class="p">,</span> <span class="nv">$cb:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{{</span>
    <span class="k">struct</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">parser</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Parser</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">start</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="n">Resume</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Cb</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="nv">'s</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">resume</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">visitor</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">impl</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="nv">'s</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.parser</span><span class="nf">.do_with_rewind</span><span class="p">(</span>
          <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.start</span><span class="p">,</span>
          <span class="p">||</span> <span class="p">(</span><span class="nv">$cb</span><span class="p">)(</span><span class="k">self</span><span class="py">.parser</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">visitor</span><span class="p">),</span>
        <span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Cb</span> <span class="p">{</span> <span class="n">parser</span><span class="p">:</span> <span class="nv">$parser</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">None</span> <span class="p">}</span>
  <span class="p">}};</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>This macro is, unsurprisingly, quite janky. It also can’t really do captures, because the <code class="language-plaintext highlighter-rouge">$cb</code> argument that contains the actual code is buried inside of a nested <code class="language-plaintext highlighter-rouge">impl</code>.</p> <p>You might think “well Miguel, why don’t you hoist <code class="language-plaintext highlighter-rouge">$cb</code> into the <code class="language-plaintext highlighter-rouge">Cb</code> struct?” The problem is now that I need to write <code class="language-plaintext highlighter-rouge">impl&lt;'s, F: FnMut(&amp;Parser&lt;'s&gt;, ???)&gt;</code> so that I can actually call the callback in the body of <code class="language-plaintext highlighter-rouge">Resume::resume</code>, but that brings us back to our trait bound problem from the start!</p> <p>This is a general problem with this type of solution: there is no macro you can write that will capture an arbitrary closure to implement a trait by calling that closure, if the method being implemented is generic, because if you <em>could</em>, I wouldn’t have to bother with the macro.</p> <h2 id="lets-talk-about-java"><a href="#lets-talk-about-java">Let’s Talk About Java</a></h2> <p>Historically, the way you would pass code as an argument in Java would be to do something like</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callback</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">runMyThing</span><span class="o">(</span><span class="nc">Callback</span> <span class="n">cb</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">cb</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">runMyThing</span><span class="o">(</span><span class="k">new</span> <span class="nc">Callback</span><span class="o">()</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="n">arg</span><span class="o">;</span> <span class="o">}</span>
<span class="o">});</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p>The <code class="language-plaintext highlighter-rouge">new Type() {...}</code> syntax would mint a new class on the spot, using the code in between the braces to provide implementations of abstract methods.</p> <p>Java 8 introduced lambdas to Java, with the syntax <code class="language-plaintext highlighter-rouge">x -&gt; expr</code>, and they wanted to be compatible with this existing code. So they built what I have come to regard a masterclass in language design.</p> <p>There are is no language-blessed <code class="language-plaintext highlighter-rouge">Function</code> interface. Instead, <em>any</em> interface with exactly one abstract method can be initialized from a lambda expression. These are called single abstract method (SAM) interfaces.</p> <p>So, without needing to touch the existing library, I can turn the <code class="language-plaintext highlighter-rouge">new</code> syntax into this:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">runMyThing</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Java</div></div></div> <p><em>chef’s kiss</em></p> <p>Mind, Java <em>does</em> provide a mess of “standard function interfaces” in the <code class="language-plaintext highlighter-rouge">java.util.functional</code> package, and quite a bit of the standard library uses them, but they don’t need to express the totality of functions you might want to capture as objects.</p> <p>These “SAM closures” give closures a powerful “BYO interface” aspect. Lambdas in Java are not “function objects”, they are extremely lightweight anonymous classes the pertinent interface.</p> <p>I think this can let us cut the gordian knot of generic closures in Rust.</p> <h2 id="sam-in-rust"><a href="#sam-in-rust">SAM in Rust</a></h2> <p>In what remains I will propose how we can extend the traits that closures implement to be <em>any</em> SAM trait, in addition to the traits they implement ipso facto.</p> <p>What’s a SAM trait in Rust? It’s any trait <code class="language-plaintext highlighter-rouge">T</code> with precisely ONE method that does not have a default implementation with the following properties:</p> <ol> <li>It must have a <code class="language-plaintext highlighter-rouge">self</code> parameter with type <code class="language-plaintext highlighter-rouge">Self</code>, <code class="language-plaintext highlighter-rouge">&amp;Self</code>, or <code class="language-plaintext highlighter-rouge">&amp;mut Self</code>.</li> <li>It does not mention <code class="language-plaintext highlighter-rouge">Self</code> in any part of its argument types, its return type, or its <code class="language-plaintext highlighter-rouge">where</code> clauses, except for the <code class="language-plaintext highlighter-rouge">self</code> parameter.</li> <li>Has no associated consts or types, or is one of the <code class="language-plaintext highlighter-rouge">Fn</code> traits.</li> <li>There are no blanket <code class="language-plaintext highlighter-rouge">impl</code>s of this trait.</li> </ol> <blockquote> <p>In addition to the <code class="language-plaintext highlighter-rouge">Fn</code> traits, closures automatically implement <code class="language-plaintext highlighter-rouge">Clone</code>, <code class="language-plaintext highlighter-rouge">Copy</code>, <code class="language-plaintext highlighter-rouge">Send</code>, and <code class="language-plaintext highlighter-rouge">Sync</code> as appropriate. We can safely ignore this automatic impl generation.</p> </blockquote> <p>Then, a closure type <code class="language-plaintext highlighter-rouge">C</code> is said to implement <code class="language-plaintext highlighter-rouge">T</code> if its body, before type inference occurs, could be used to implement this unique abstract methodl, transforming captures into <code class="language-plaintext highlighter-rouge">self.field</code> accesses in the expected way (in fact, in the <em>exact way</em> in which a <code class="language-plaintext highlighter-rouge">Fn</code> impl is generated).</p> <p>This means that I could just write</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">call_many</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Callback</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
  <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="nf">.run</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">call_many</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">());</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>We need (1) above, since the method needs to match to one of <code class="language-plaintext highlighter-rouge">Fn</code>, <code class="language-plaintext highlighter-rouge">FnMut</code>, or <code class="language-plaintext highlighter-rouge">FnOnce</code>’s methods.</p> <p>We requite (2) because it is virtually impossible to name a closure within itself without greating a type of infinite size. It is better to not worry about the consequences of any of this.</p> <p>We require (3) because inferring associated consts is impossible, and I don’t want to try to specify a way by which we can infer associated types, which the <code class="language-plaintext highlighter-rouge">Fn</code> traits are simple enough to be able to do on their own.</p> <p>We require (4) because we do not want to get a situation like the following:</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">T1</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">T2</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">T1</span><span class="o">&gt;</span> <span class="n">T2</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"not actually gonna call T1::foo() lmao"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
<span class="nn">T2</span><span class="p">::</span><span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c">// What should this print?</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>If the type of <code class="language-plaintext highlighter-rouge">x</code> implements <code class="language-plaintext highlighter-rouge">T2</code> directly, we print <code class="language-plaintext highlighter-rouge">"hello"</code>, but if we decide it implements <code class="language-plaintext highlighter-rouge">T1</code> instead, it doesn’t, because we get the blanket impl. If it decides it should implement both… we get a coherence violation.</p> <h3 id="soooo-what-does-this-do-to-type-inference"><a href="#soooo-what-does-this-do-to-type-inference">Soooo… What does this do to type inference?</a></h3> <p>Ok, that seems easy, right? Unfortunately we need to face up with the usual problem of type inference in Rust: because inference is a constraint solver, we need to make sure we do not accidentally change the constraints the type checker sees that would cause it to cause existing code to break or infer different types.</p> <p>When I write a closure with elided type annotations, the compiler will try to produce a unique answer for what those annotations are.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="mi">5</span><span class="p">;</span>
<span class="nn">f</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
<span class="nn">f</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span> <span class="c">// error: type mismatch in closure arguments</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>I was also somewhat hand-wavy when I said “before type inference occurs, could be used to implement this unique abstract method”. This is effectively asking for a compiler-generated impl to be minted only when a particular interpretation of the closure’s input and output types can be uniquely chosen to make the body type-check.</p> <p>This gets worse when you realize that a closure can influence the types of things outside of it.</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnMut</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
<span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">v</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="nn">f</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
<span class="nn">f</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>Now whatever we pick for <code class="language-plaintext highlighter-rouge">x</code> influences the type of <code class="language-plaintext highlighter-rouge">v</code>. This gives closures a slightly “macro” quality, because dependning on which trait a closure is called through, it might have different behavior depending on how type inference worked out.</p> <p>I think this particular problem can be worked around by declaring that a closure can only be called upon to implement exactly one trait via this mechanism (up to potentially capturing generic parameters as in the code below).</p> <div class="codeblock"><figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">convert_to</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Into</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
  <span class="p">||</span> <span class="n">x</span><span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure><div class="codeblock-buttons"><div class="codeblock-button">Rust</div></div></div> <p>(We need to make an exception for <code class="language-plaintext highlighter-rouge">FnOnce</code>, <code class="language-plaintext highlighter-rouge">FnMut</code>, and <code class="language-plaintext highlighter-rouge">Fn</code>, which are automatically implemented together; these traits are well-understood by the compiler so it should not pose an issue.)</p> <p>Now, I don’t think this problem kills the idea, but it does mean we need to be very careful that it does not change type inference. I am not an expert on precisely how inference around closures works, so I’m mostly hoping that there isn’t some existing use-case that makes this categorically impossible.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>Generic lambdas are extremely powerful in C++, and allow for very slick API designs; I often miss them in Rust. Although it feels like there is an insurmountable obstruction, I hope that the SAM interface approach offers a simpler, and possibly more pragmatic, approach to making them work in Rust.</p> </div> <div class="related post-footer"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <a href="/2023/04/04/trait-rez-wishlist/"> <small class="post-meta-flat">2023-04-04</small> Better Trait Resolution in Rust </a> <li> <a href="/2023/03/29/rseq-checkout/"> <small class="post-meta-flat">2023-03-29</small> Atomicless Concurrency </a> <li> <a href="/2022/07/24/curta/"> <small class="post-meta-flat">2022-07-24</small> 3Hz Computer, Hold the Transistors </a> </ul> </div> </div> </div> </div></div> </body> <div class="sidebar show-if-mobile"> <div class="container sidebar-sticky"> &copy; 2023 Miguel Young de la Sota <br/> <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA</a> </div> </div> </html>